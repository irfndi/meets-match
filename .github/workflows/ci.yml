name: CI

on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        python-version: ["3.10", "3.11", "3.12"]

    services:
      postgres:
        image: postgres:latest
        env:
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: test_db
        ports:
          - 5432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
    - uses: actions/checkout@v4
    
    - name: Set up Python ${{ matrix.python-version }}
      uses: actions/setup-python@v4
      with:
        python-version: ${{ matrix.python-version }}
        
    - name: Install uv
      run: |
        curl -LsSf https://astral.sh/uv/install.sh | sh
        
    - name: Install dependencies
      run: |
        # Use Python's built-in venv module instead of uv venv
        python -m venv .venv
        source .venv/bin/activate
        
        # Explicitly install python-dotenv to avoid conflicts
        pip install python-dotenv>=0.19.0
        
        # Install dependencies from version-3 directory
        pip install -r version-3/requirements.txt
        pip install coverage codecov
        
        # List installed packages for debugging
        pip list | grep dotenv
        
    - name: Check PostgreSQL Service Status
      run: |
        # Install PostgreSQL client tools
        sudo apt-get update && sudo apt-get install -y postgresql-client net-tools
        # Check if PostgreSQL is running and accessible
        pg_isready -h localhost -p 5432
        # Try a basic connection to verify credentials
        PGPASSWORD=postgres psql -h localhost -U postgres -d test_db -c "SELECT 1" || echo "PostgreSQL connection failed"
        # Print service logs if available
        echo "\n--- PostgreSQL Service Status ---"
        sudo netstat -tulpn | grep 5432 || echo "PostgreSQL port not listening"
        # Check container logs if possible
        echo "\n--- Docker Container Status ---"
        sudo docker ps -a || echo "Docker command not available"
        
    - name: Verify PostgreSQL Connection
      run: |
        # Wait for PostgreSQL to be fully ready
        echo "Waiting for PostgreSQL to be fully ready..."
        for i in {1..10}; do
          if PGPASSWORD=postgres psql -h localhost -U postgres -d test_db -c "SELECT 1" &>/dev/null; then
            echo "PostgreSQL is ready!"
            break
          fi
          echo "Attempt $i: PostgreSQL not ready yet, waiting..."
          sleep 3
        done
        # Final check
        if ! PGPASSWORD=postgres psql -h localhost -U postgres -d test_db -c "SELECT 1" &>/dev/null; then
          echo "ERROR: PostgreSQL is still not accessible after waiting"
          exit 1
        fi

    - name: Create required database roles
      run: |
        # Create the 'root' role that's needed for tests
        echo "Creating required database roles..."
        PGPASSWORD=postgres psql -h localhost -U postgres -d test_db -c "CREATE ROLE root WITH LOGIN SUPERUSER PASSWORD 'root';" || echo "Role 'root' might already exist"
        
        # List all roles to verify
        echo "Verifying database roles:"
        PGPASSWORD=postgres psql -h localhost -U postgres -d test_db -c "\du"

    - name: Configure environment for tests
      run: |
        # Create test environment file from sample in version-3 directory
        cp version-3/.env.sample version-3/.env.test
        
        # Override database connection settings
        echo "POSTGRES_HOST=localhost" >> version-3/.env.test
        echo "POSTGRES_PORT=5432" >> version-3/.env.test
        echo "POSTGRES_USER=postgres" >> version-3/.env.test
        echo "POSTGRES_PASSWORD=postgres" >> version-3/.env.test
        echo "POSTGRES_DB=test_db" >> version-3/.env.test
        echo "ENVIRONMENT=test" >> version-3/.env.test
        
        # Display environment (excluding sensitive values)
        echo "Test environment configuration:"
        cat version-3/.env.test | grep -v PASSWORD | grep -v KEY | grep -v TOKEN
        
        # Copy to .env for tests that look for it
        cp version-3/.env.test version-3/.env
        
        # Also create a copy at the repository root for backward compatibility
        cp version-3/.env.test .env

    - name: Run tests with coverage
      env:
        # Secret environment variables (these will not be exposed in logs)
        BOT_TOKEN: ${{ secrets.BOT_TOKEN }}
        AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
        AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        AWS_S3_BUCKET: ${{ secrets.AWS_S3_BUCKET }}
      run: |
        # Activate the virtual environment
        source .venv/bin/activate
        
        # Change to version-3 directory and run tests
        cd version-3
        coverage run -m unittest discover
        coverage xml
        
        # Copy coverage report to the repository root for the next step
        cp coverage.xml ../coverage.xml
        
    - name: Verify coverage file
      run: ls -la && test -f coverage.xml

    - name: Upload coverage to Codecov
      if: success()
      uses: codecov/codecov-action@v3
      with:
        token: ${{ secrets.CODECOV_TOKEN }}
        files: ./coverage.xml
        flags: unittests
        verbose: true
        name: codecov-umbrella
        fail_ci_if_error: true
