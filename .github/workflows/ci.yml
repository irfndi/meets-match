name: CI

on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        python-version: ["3.10", "3.11", "3.12"]

    services:
      postgres:
        image: postgres:latest
        env:
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: test_db
        ports:
          - 5432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
    - uses: actions/checkout@v4
    
    - name: Set up Python ${{ matrix.python-version }}
      uses: actions/setup-python@v4
      with:
        python-version: ${{ matrix.python-version }}
        
    - name: Install uv
      run: |
        curl -LsSf https://astral.sh/uv/install.sh | sh
        
    - name: Install dependencies
      run: |
        uv venv
        uv pip install -r requirements.txt
        uv pip install coverage codecov
        
    - name: Check PostgreSQL Service Status
      run: |
        # Install PostgreSQL client tools
        sudo apt-get update && sudo apt-get install -y postgresql-client net-tools
        # Check if PostgreSQL is running and accessible
        pg_isready -h localhost -p 5432
        # Try a basic connection to verify credentials
        PGPASSWORD=postgres psql -h localhost -U postgres -d test_db -c "SELECT 1" || echo "PostgreSQL connection failed"
        # Print service logs if available
        echo "\n--- PostgreSQL Service Status ---"
        sudo netstat -tulpn | grep 5432 || echo "PostgreSQL port not listening"
        # Check container logs if possible
        echo "\n--- Docker Container Status ---"
        sudo docker ps -a || echo "Docker command not available"
        
    - name: Verify PostgreSQL Connection
      run: |
        # Wait for PostgreSQL to be fully ready
        echo "Waiting for PostgreSQL to be fully ready..."
        for i in {1..10}; do
          if PGPASSWORD=postgres psql -h localhost -U postgres -d test_db -c "SELECT 1" &>/dev/null; then
            echo "PostgreSQL is ready!"
            break
          fi
          echo "Attempt $i: PostgreSQL not ready yet, waiting..."
          sleep 3
        done
        # Final check
        if ! PGPASSWORD=postgres psql -h localhost -U postgres -d test_db -c "SELECT 1" &>/dev/null; then
          echo "ERROR: PostgreSQL is still not accessible after waiting"
          exit 1
        fi

    - name: Create required database roles
      run: |
        # Create the 'root' role that's needed for tests
        echo "Creating required database roles..."
        PGPASSWORD=postgres psql -h localhost -U postgres -d test_db -c "CREATE ROLE root WITH LOGIN SUPERUSER PASSWORD 'root';" || echo "Role 'root' might already exist"
        
        # List all roles to verify
        echo "Verifying database roles:"
        PGPASSWORD=postgres psql -h localhost -U postgres -d test_db -c "\du"

    - name: Configure environment for tests
      run: |
        # Create test environment file from sample
        cp .env.sample .env.test
        # Override database connection settings
        echo "POSTGRES_HOST=localhost" >> .env.test
        echo "POSTGRES_PORT=5432" >> .env.test
        echo "POSTGRES_USER=postgres" >> .env.test
        echo "POSTGRES_PASSWORD=postgres" >> .env.test
        echo "POSTGRES_DB=test_db" >> .env.test
        echo "ENVIRONMENT=test" >> .env.test
        # Display environment (excluding sensitive values)
        echo "Test environment configuration:"
        cat .env.test | grep -v PASSWORD | grep -v KEY | grep -v TOKEN
        # Copy to .env for tests that look for it
        cp .env.test .env

    - name: Run tests with coverage
      env:
        # Secret environment variables (these will not be exposed in logs)
        BOT_TOKEN: ${{ secrets.BOT_TOKEN }}
        AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
        AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        AWS_S3_BUCKET: ${{ secrets.AWS_S3_BUCKET }}
      run: |
        coverage run -m unittest discover
        coverage xml
        
    - name: Verify coverage file
      run: ls -la && test -f coverage.xml

    - name: Upload coverage to Codecov
      if: success()
      uses: codecov/codecov-action@v3
      with:
        token: ${{ secrets.CODECOV_TOKEN }}
        files: ./coverage.xml
        flags: unittests
        verbose: true
        name: codecov-umbrella
        fail_ci_if_error: true
