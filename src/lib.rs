mod utils;
mod config_service;
mod monitoring_service;
mod security_service;
mod user_service;
mod matching_service;
mod communication_service;
mod analytics_service;
mod notification_service;
mod rbac_service;
pub mod media_service;

use worker::*;
use serde::{Deserialize, Serialize};
use serde_json::json;

use config_service::{ConfigService, EnvironmentConfig};
use user_service::{UserService, User as DomainUser, UserState, MAX_USER_MEDIA_ITEMS};
use rbac_service::{RBACService, Role as UserRole};
use media_service::MediaService;
use chrono::{DateTime, Duration, Utc};


// --- Telegram Type Definitions ---
#[derive(Deserialize, Debug, Clone)] pub struct TelegramLocation { pub latitude: f64, pub longitude: f64 }
#[derive(Deserialize, Debug, Clone)] pub struct TelegramPhotoSize { pub file_id: String, pub file_unique_id: String, pub width: u32, pub height: u32, pub file_size: Option<u32> }
#[derive(Deserialize, Debug, Clone)] pub struct TelegramVideo { pub file_id: String, pub file_unique_id: String, pub width: u32, pub height: u32, pub duration: u32, pub mime_type: Option<String>, pub file_name: Option<String>, pub file_size: Option<u32> }
#[derive(Deserialize, Debug, Clone)] pub struct TelegramDocument { pub file_id: String, pub file_unique_id: String, pub file_name: Option<String>, pub mime_type: Option<String>, pub file_size: Option<u32> }
#[derive(Deserialize, Debug, Clone)] pub struct TelegramMessage { pub message_id: i64, pub from: Option<TelegramUser>, pub chat: TelegramChat, pub date: i64, pub text: Option<String>, pub location: Option<TelegramLocation>, pub photo: Option<Vec<TelegramPhotoSize>>, pub video: Option<TelegramVideo>, pub document: Option<TelegramDocument> }
#[derive(Deserialize, Debug)] pub struct TelegramUpdate { pub message: Option<TelegramMessage> }
#[derive(Deserialize, Debug, Clone)] pub struct TelegramUser { pub id: i64, pub username: Option<String> }
#[derive(Deserialize, Debug, Clone)] pub struct TelegramChat { pub id: i64 }
#[derive(Deserialize, Debug)] pub struct TelegramFile { pub file_size: Option<u64>, pub file_path: Option<String> }
#[derive(Deserialize, Debug)] pub struct TelegramApiResponse<T> { pub ok: bool, pub result: Option<T>, pub description: Option<String>, pub error_code: Option<i32> }
// --- End of Telegram Type Definitions ---

// --- Profile Editing Session Types ---
#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)] pub enum EditingField { Name, Age, Gender, Bio, LocationText }
#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)] pub enum CurrentEditingStep { SelectingField, AwaitingValue(EditingField), AwaitingMediaFile, AwaitingMediaDeletionChoice(Vec<String>) }
#[derive(Serialize, Deserialize, Debug, Clone)] pub struct ProfileEditingSession { pub user_id: String, pub chat_id: i64, pub step: CurrentEditingStep, pub prompted_at: DateTime<Utc> }
const PROFILE_EDIT_SESSION_KEY_PREFIX: &str = "profile_edit_session_v1:";
// --- End Profile Editing Session Types ---

// --- KV Helper Functions ---
fn get_session_kv(env: &Env) -> Result<KvStore> { env.kv("SESSIONS_KV") }
fn format_session_key(chat_id: i64) -> String { format!("{}{}", PROFILE_EDIT_SESSION_KEY_PREFIX, chat_id) }
async fn set_profile_editing_session(env: &Env, session: &ProfileEditingSession) -> Result<()> { let store = get_session_kv(env)?; let key = format_session_key(session.chat_id); let session_json = serde_json::to_string(session).map_err(|e| worker::Error::RustError(format!("Serialization error: {}", e)))?; store.put_with_options(&key, session_json)?.expiration_ttl(900).execute().await?; Ok(()) }
async fn get_profile_editing_session(env: &Env, chat_id: i64) -> Result<Option<ProfileEditingSession>> { match get_session_kv(env) { Ok(store) => { let key = format_session_key(chat_id); match store.get(&key).json::<ProfileEditingSession>().await { Ok(Some(s)) => Ok(Some(s)), Ok(None) => Ok(None), Err(e) => { let es = e.to_string(); if es.contains("deserialize") || es.contains("invalid type") { console_warn!("[KV] Corrupt session for {}: {}. Deleting.", chat_id, es); if let Err(de) = store.delete(&key).await { console_error!("[KV] Failed delete corrupt key {}: {}", key, de); } Ok(None) } else { console_error!("[KV] Error get session {}: {}", chat_id, es); Err(e) } } } } Err(e) => { console_error!("[KV] CRITICAL: Failed get SESSIONS_KV store: {}. Check wrangler.toml.", e); Err(e) } } }
async fn clear_profile_editing_session(env: &Env, chat_id: i64) -> Result<()> { match get_session_kv(env) { Ok(store) => { store.delete(&format_session_key(chat_id)).await?; console_log!("[KV] Cleared session for chat_id {}", chat_id); Ok(()) } Err(e) => { console_error!("[KV] CRITICAL: Failed get SESSIONS_KV for delete: {}. Check wrangler.toml.", e); Err(e) } } }
// --- End KV Helper Functions ---

// --- Validation Logic ---
#[derive(Debug, PartialEq)] pub enum ValidationError { TooShort(usize), TooLong(usize), InvalidFormat(String), OutOfRange { min: String, max: String } }
impl ToString for ValidationError { fn to_string(&self) -> String { match self { ValidationError::TooShort(min) => format!("Input too short\\. Min length {}\\.", min), ValidationError::TooLong(max) => format!("Input too long\\. Max length {}\\.", max), ValidationError::InvalidFormat(reason) => escape_markdown_v2(reason), ValidationError::OutOfRange{ min, max } => format!("Value out of range\\. Must be {} - {}\\.", min, max), } } }
const MIN_NAME_LEN: usize = 1; const MAX_NAME_LEN: usize = 50; const MIN_AGE: u8 = 13; const MAX_AGE: u8 = 99; const MAX_GENDER_LEN: usize = 50; const MIN_GENDER_LEN: usize = 0; const MAX_BIO_LEN: usize = 250; const MAX_LOCATION_TEXT_LEN: usize = 100;
pub fn validate_name(name: &str) -> Result<(), ValidationError> { let t=name.trim(); if t.len()<MIN_NAME_LEN{Err(ValidationError::TooShort(MIN_NAME_LEN))}else if t.len()>MAX_NAME_LEN{Err(ValidationError::TooLong(MAX_NAME_LEN))}else{Ok(())}}
pub fn validate_age(age_str: &str) -> Result<u8, ValidationError> { match age_str.trim().parse::<u8>(){Ok(v)if v>=MIN_AGE&&v<=MAX_AGE=>Ok(v), Ok(age_val)=>Err(ValidationError::OutOfRange{min:MIN_AGE.to_string(),max:MAX_AGE.to_string()}),Err(_)=>Err(ValidationError::InvalidFormat("Age must be a number.".to_string()))}}
pub fn validate_gender(gender: &str) -> Result<(), ValidationError> { let t=gender.trim(); if t.len()<MIN_GENDER_LEN&& !t.is_empty(){Err(ValidationError::TooShort(MIN_GENDER_LEN))}else if t.len()>MAX_GENDER_LEN{Err(ValidationError::TooLong(MAX_GENDER_LEN))}else{Ok(())}}
pub fn validate_bio(bio: &str) -> Result<(), ValidationError> { let t=bio.trim(); if t.len()>MAX_BIO_LEN{Err(ValidationError::TooLong(MAX_BIO_LEN))}else{Ok(())}}
pub fn validate_location_text(loc: &str) -> Result<(), ValidationError> { let t=loc.trim(); if t.is_empty(){Ok(())}else if t.len()>MAX_LOCATION_TEXT_LEN{Err(ValidationError::TooLong(MAX_LOCATION_TEXT_LEN))}else{Ok(())}}
// --- End Validation Logic ---

// --- Formatting & Parsing Helpers ---
fn escape_markdown_v2(text: &str) -> String { let s = r#"_*[]()~`>#+-=|{}.!"#; let mut o = String::new(); for c in text.chars() { if s.contains(c) { o.push('\\'); } o.push(c); } o }
fn format_user_profile_view(user: &DomainUser) -> String { let n=user.name.as_deref().map_or_else(||"Not set".to_string(),escape_markdown_v2); let a=user.age.map_or("Not set".to_string(),|v|v.to_string()); let g=user.gender.as_deref().map_or_else(||"Not set".to_string(),escape_markdown_v2); let b=user.bio.as_deref().map_or_else(||"Not set".to_string(),escape_markdown_v2); let l=match(&user.location_text,user.latitude,user.longitude){(Some(t),Some(lt),Some(ln))=>format!("{} \\(Lat: {:.3}, Lon: {:.3}\\)",escape_markdown_v2(t),lt,ln),(Some(t),_,_)=>escape_markdown_v2(t),(None,Some(lt),Some(ln))=>format!("Lat: {:.3}, Lon: {:.3}",lt,ln),_=>"Not set".to_string()}; let mc=user.media_keys.len(); let mut mls=String::new(); if !user.media_keys.is_empty(){for(i,_)in user.media_keys.iter().enumerate(){mls.push_str(&format!("\n  {}\\. Media Item {}",i+1,i+1));}} let m_sec=if user.media_keys.is_empty(){format!("{} item\\(s\\)",mc)}else{format!("{} item\\(s\\){}",mc,mls)}; format!("*Your Profile*\n\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\nðŸ·ï¸ *Name*: {}\nðŸŽ‚ *Age*: {}\nðŸ‘¤ *Gender*: {}\nðŸ“ *Bio*: {}\nðŸ“ *Location*: {}\nðŸ–¼ï¸ *Media Items*: {}\n\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\n*Technical Info:*\nTelegram ID: `{}`\nUser ID: `{}`\nRoles: `{:?}`\nState: `{:?}`\nJoined: `{}`\nLast Interaction: `{}`\n\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\nTo edit, use `/profile edit`\\.\nTo add media, use `/profile add_media`\\.\nTo delete media, use `/profile delete_media` \\(soon\\!\\)\\.",n,a,g,b,l,m_sec,user.telegram_id,user.id,user.roles,user.state,user.created_at.format("%Y-%m-%d %H:%M UTC"),user.last_interaction_at.format("%Y-%m-%d %H:%M UTC"))}
fn parse_editing_field_choice(text: &str) -> Option<EditingField> { match text.trim().to_lowercase().as_str() { "name"=>Some(EditingField::Name),"age"=>Some(EditingField::Age),"gender"=>Some(EditingField::Gender),"bio"=>Some(EditingField::Bio),"location"=>Some(EditingField::LocationText),_=>None } }
// --- End Formatting & Parsing Helpers ---

// --- Telegram File Download Helper ---
async fn download_telegram_file(env: &Env, file_id: &str) -> Result<Vec<u8>> { let bot_token=env.secret("TELEGRAM_TOKEN")?.to_string();let get_file_url_str=format!("https://api.telegram.org/bot{}/getFile?file_id={}",bot_token,file_id);let get_file_url=get_file_url_str.parse()?;let mut response=Fetch::Url(get_file_url).send().await?;if response.status_code()!=200{let body=response.text().await.unwrap_or_default();console_error!("[TelegramDL] getFile API error {}: {}",response.status_code(),body);return Err(Error::RustError(format!("Telegram getFile API error: {}",response.status_code())));}let file_api_response:TelegramApiResponse<TelegramFile>=response.json().await.map_err(|e|{console_error!("[TelegramDL] Failed to parse getFile JSON response: {}",e);Error::RustError(format!("Telegram getFile JSON parse error: {}",e))})?;if !file_api_response.ok||file_api_response.result.is_none()||file_api_response.result.as_ref().unwrap().file_path.is_none(){console_error!("[TelegramDL] Telegram getFile API call not OK or missing file_path: {:?}",file_api_response.description);return Err(Error::RustError("Failed to get file path from Telegram".to_string()));}let file_path=file_api_response.result.unwrap().file_path.unwrap();let file_download_url_str=format!("https://api.telegram.org/file/bot{}/{}",bot_token,file_path);let file_download_url=file_download_url_str.parse()?;let mut file_response=Fetch::Url(file_download_url).send().await?;if file_response.status_code()!=200{let body=file_response.text().await.unwrap_or_default();console_error!("[TelegramDL] File download error {}: {}",file_response.status_code(),body);return Err(Error::RustError(format!("Telegram file download error: {}",file_response.status_code())));}file_response.bytes().await.map_err(|e|Error::RustError(format!("Failed to read file bytes: {}",e)))}
// --- End Telegram File Download Helper ---

// --- Command & Message Handlers ---
async fn handle_profile_edit_initiate( env: &Env, user: &DomainUser, chat_id: i64 ) -> Result<Response> { let s = ProfileEditingSession { user_id: user.id.clone(), chat_id, step: CurrentEditingStep::SelectingField, prompted_at: Utc::now() }; match set_profile_editing_session(env, &s).await { Ok(_) => { let pt = "Okay, let's edit your profile\\.\n\nWhich field would you like to change\\?\nChoose from: `Name`, `Age`, `Gender`, `Bio`, `Location`\\.\n\nType your choice \\(e\\.g\\., 'Name'\\), or type `cancel` to abort\\."; Response::from_json(&json!({ "method": "sendMessage", "chat_id": chat_id, "text": pt, "parse_mode": "MarkdownV2" })) } Err(e) => { console_error!("[ProfileEdit] Failed to set session for {}: {}", user.id, e); Response::from_json(&json!({ "method": "sendMessage", "chat_id": chat_id, "text": "Error starting edit process\\. Try again\\." })) } } }
async fn handle_profile_add_media_initiate( env: &Env, user: &DomainUser, chat_id: i64 ) -> Result<Response> { if user.media_keys.len()>=MAX_USER_MEDIA_ITEMS{return Response::from_json!(&json!({"method":"sendMessage","chat_id":chat_id,"text":format!("Max {} media items reached\\.",MAX_USER_MEDIA_ITEMS),"parse_mode":"MarkdownV2"}));} let ns=ProfileEditingSession{user_id:user.id.clone(),chat_id,step:CurrentEditingStep::AwaitingMediaFile,prompted_at:Utc::now()}; match set_profile_editing_session(env,&ns).await{Ok(_)=>Response::from_json!(&json!({"method":"sendMessage","chat_id":chat_id,"text":"Send photo/video (max 20MB), or `cancel`\\.","parse_mode":"MarkdownV2"})),Err(e)=>{console_error!("Failed set AwaitingMediaFile session {}: {}",user.id,e);Response::from_json!(&json!({"method":"sendMessage","chat_id":chat_id,"text":"Error preparing media upload."}))}}}
async fn handle_profile_delete_media_initiate( env: &Env, _user_service: &UserService, user: &DomainUser, chat_id: i64 ) -> Result<Response> { if user.media_keys.is_empty(){return Response::from_json!(&json!({"method":"sendMessage","chat_id":chat_id,"text":"No media to delete\\. Use `/profile add_media`\\.","parse_mode":"MarkdownV2"}));}let mut list="Delete which media\\?\n\n".to_string();for(i,k)in user.media_keys.iter().enumerate(){let fname=k.split('/').last().unwrap_or("file");list.push_str(&format!("{}\\. `{}`\n",i+1,escape_markdown_v2(fname)));}list.push_str("\nReply with number, or `cancel`\\.");let ns=ProfileEditingSession{user_id:user.id.clone(),chat_id,step:CurrentEditingStep::AwaitingMediaDeletionChoice(user.media_keys.clone()),prompted_at:Utc::now()};match set_profile_editing_session(env,&ns).await{Ok(_)=>Response::from_json!(&json!({"method":"sendMessage","chat_id":chat_id,"text":list,"parse_mode":"MarkdownV2"})),Err(e)=>{console_error!("Failed set AwaitingMediaDeletionChoice session {}: {}",user.id,e);Response::from_json!(&json!({"method":"sendMessage","chat_id":chat_id,"text":"Error starting media deletion."}))}}}

async fn handle_text_message( env: &Env, user_service: &UserService, _env_config: &EnvironmentConfig, telegram_user_opt: Option<TelegramUser>, chat_id: i64, text: &str ) -> Result<Response> { if let Some(session)=get_profile_editing_session(env,chat_id).await?{let uid_session=session.user_id.clone();if text.eq_ignore_ascii_case("cancel"){clear_profile_editing_session(env,chat_id).await?;return Response::from_json!(&json!({"method":"sendMessage","chat_id":chat_id,"text":"Profile edit cancelled."}));}match session.step{CurrentEditingStep::SelectingField=>{if let Some(cf)=parse_editing_field_choice(text){let mut us=session.clone();us.step=CurrentEditingStep::AwaitingValue(cf.clone());us.prompted_at=Utc::now();set_profile_editing_session(env,&us).await?;let uo=user_service.get_user_by_id(&session.user_id).await?;let cvp=if let Some(ref u)=uo{match cf{EditingField::Name=>format!("\\(Current: {}\\)",escape_markdown_v2(u.name.as_deref().unwrap_or("Not set"))),EditingField::Age=>format!("\\(Current: {}\\)",u.age.map_or("Not set".to_string(),|a|a.to_string())),EditingField::Gender=>format!("\\(Current: {}\\)",escape_markdown_v2(u.gender.as_deref().unwrap_or("Not set"))),EditingField::Bio=>format!("\\(Current: {}\\)",escape_markdown_v2(u.bio.as_deref().unwrap_or("Not set"))),EditingField::LocationText=>{let lt=match(&u.location_text,u.latitude,u.longitude){(Some(t),_,_)=>escape_markdown_v2(t),(None,Some(lat),Some(lon))=>format!("Coordinates \\({:.3}, {:.3}\\)",lat,lon),_=>"Not set".to_string()};format!("\\(Current: {}\\)",lt)}}}else{"".to_string()};let pt=match cf{EditingField::Name=>format!("New Name? {}",cvp),EditingField::Age=>format!("New Age (13-99)? {}",cvp),EditingField::Gender=>format!("New Gender? {}",cvp),EditingField::Bio=>format!("New Bio (max 250 chars)? {}",cvp),EditingField::LocationText=>format!("New Location text (max 100 chars)? {}",cvp),};Response::from_json!(&json!({"method":"sendMessage","chat_id":chat_id,"text":pt,"parse_mode":"MarkdownV2"}))}else{Response::from_json!(&json!({"method":"sendMessage","chat_id":chat_id,"text":"Invalid choice\\. Use `Name`, `Age`, etc\\., or `cancel`\\.","parse_mode":"MarkdownV2"}))}}CurrentEditingStep::AwaitingValue(ref f)=>{let nvt=text.trim();match f{EditingField::Name=>match validate_name(nvt){Ok(_)=>match user_service.update_user_name(&uid_session,nvt.to_string()).await{Ok(u)=>{clear_profile_editing_session(env,chat_id).await?;Response::from_json!(&json!({"method":"sendMessage","chat_id":chat_id,"text":format!("Name updated: {}\\. /profile",escape_markdown_v2(u.name.as_deref().unwrap_or_default())),"parse_mode":"MarkdownV2"}))}Err(e)=>{console_error!("Err updating name for {}: {}",uid_session,e);Response::from_json!(&json!({"method":"sendMessage","chat_id":chat_id,"text":"Error updating name. Try `cancel` or again."}))}}Err(ve)=>Response::from_json!(&json!({"method":"sendMessage","chat_id":chat_id,"text":format!("Invalid name: {}\\. Try again or `cancel`\\.",ve.to_string()),"parse_mode":"MarkdownV2"}))}EditingField::Age=>match validate_age(nvt){Ok(age)=>match user_service.update_user_age(&uid_session,age).await{Ok(u)=>{clear_profile_editing_session(env,chat_id).await?;Response::from_json!(&json!({"method":"sendMessage","chat_id":chat_id,"text":format!("Age updated: {}\\. /profile",u.age.unwrap_or(0))}))}Err(e)=>{console_error!("Err updating age for {}: {}",uid_session,e);Response::from_json!(&json!({"method":"sendMessage","chat_id":chat_id,"text":"Error updating age. Try `cancel` or again."}))}}Err(ve)=>Response::from_json!(&json!({"method":"sendMessage","chat_id":chat_id,"text":format!("Invalid age: {}\\. Try again or `cancel`\\.",ve.to_string()),"parse_mode":"MarkdownV2"}))}EditingField::Gender=>match validate_gender(nvt){Ok(_)=>match user_service.update_user_gender(&uid_session,nvt.to_string()).await{Ok(u)=>{clear_profile_editing_session(env,chat_id).await?;Response::from_json!(&json!({"method":"sendMessage","chat_id":chat_id,"text":format!("Gender updated: {}\\. /profile",escape_markdown_v2(u.gender.as_deref().unwrap_or_default())),"parse_mode":"MarkdownV2"}))}Err(e)=>{console_error!("Err updating gender for {}: {}",uid_session,e);Response::from_json!(&json!({"method":"sendMessage","chat_id":chat_id,"text":"Error updating gender. Try `cancel` or again."}))}}Err(ve)=>Response::from_json!(&json!({"method":"sendMessage","chat_id":chat_id,"text":format!("Invalid gender: {}\\. Try again or `cancel`\\.",ve.to_string()),"parse_mode":"MarkdownV2"}))}EditingField::Bio=>match validate_bio(nvt){Ok(_)=>match user_service.update_user_bio(&uid_session,nvt.to_string()).await{Ok(_)=>{clear_profile_editing_session(env,chat_id).await?;Response::from_json!(&json!({"method":"sendMessage","chat_id":chat_id,"text":"Bio updated\\. /profile","parse_mode":"MarkdownV2"}))}Err(e)=>{console_error!("Err updating bio for {}: {}",uid_session,e);Response::from_json!(&json!({"method":"sendMessage","chat_id":chat_id,"text":"Error updating bio. Try `cancel` or again."}))}}Err(ve)=>Response::from_json!(&json!({"method":"sendMessage","chat_id":chat_id,"text":format!("Invalid bio: {}\\. Try again or `cancel`\\.",ve.to_string()),"parse_mode":"MarkdownV2"}))}EditingField::LocationText=>match validate_location_text(nvt){Ok(_)=>match user_service.update_user_location(&uid_session,Some(nvt.to_string()),None,None).await{Ok(u)=>{clear_profile_editing_session(env,chat_id).await?;Response::from_json!(&json!({"method":"sendMessage","chat_id":chat_id,"text":format!("Location text updated: {}\\. /profile",escape_markdown_v2(u.location_text.as_deref().unwrap_or_default())),"parse_mode":"MarkdownV2"}))}Err(e)=>{console_error!("Err updating location text for {}: {}",uid_session,e);Response::from_json!(&json!({"method":"sendMessage","chat_id":chat_id,"text":"Error updating location. Try `cancel` or again."}))}}Err(ve)=>Response::from_json!(&json!({"method":"sendMessage","chat_id":chat_id,"text":format!("Invalid location: {}\\. Try again or `cancel`\\.",ve.to_string()),"parse_mode":"MarkdownV2"}))}}}}CurrentEditingStep::AwaitingMediaFile=>{Response::from_json!(&json!({"method":"sendMessage","chat_id":chat_id,"text":"Please send a photo/video, or type `cancel`."}))}CurrentEditingStep::AwaitingMediaDeletionChoice(ref displayed_keys)=>{match text.trim().parse::<usize>(){Ok(num)if num>0&&num<=displayed_keys.len()=>{let key_to_del=&displayed_keys[num-1];let media_svc=match MediaService::new(env){Ok(ms)=>ms,Err(e)=>{console_error!("Failed init MediaService in AwaitingMediaDeletionChoice: {}",e);return Response::from_json!(&json!({"method":"sendMessage","chat_id":chat_id,"text":"Error processing. Try again."}));}};match media_svc.delete_media(key_to_del).await{Ok(_)=>{match user_service.remove_media_key_from_user(&uid_session,key_to_del).await{Ok(_)=>{clear_profile_editing_session(env,chat_id).await?;Response::from_json!(&json!({"method":"sendMessage","chat_id":chat_id,"text":format!("Media item `{}` deleted.",escape_markdown_v2(key_to_del.split('/').last().unwrap_or("file"))),"parse_mode":"MarkdownV2"}))}Err(e)=>{console_error!("Failed remove media key {} from D1 for {}: {}",key_to_del,uid_session,e);clear_profile_editing_session(env,chat_id).await?;Response::from_json!(&json!({"method":"sendMessage","chat_id":chat_id,"text":"Media deleted from storage, but profile update failed. Check /profile."}))}}}Err(e)=>{console_error!("Failed R2 delete for key {}: {}",key_to_del,e);Response::from_json!(&json!({"method":"sendMessage","chat_id":chat_id,"text":"Could not delete from storage. Try again or `cancel`."}))}}} _=>Response::from_json!(&json!({"method":"sendMessage","chat_id":chat_id,"text":"Invalid selection number. Try again or `cancel`."}))}}}}else{if let Some(ref tu)=telegram_user_opt{if let Some(cu)=user_service.get_user_by_telegram_id(tu.id).await?{if cu.state==UserState::Onboarding&&cu.name.is_none(){let nts=text.trim();if nts.is_empty()||nts.len()>50||nts.starts_with('/') {return Response::from_json!(&json!({"method":"sendMessage","chat_id":chat_id,"text":"Invalid name."}));}match user_service.update_user_state_and_name(cu.id.clone(),Some(nts.to_string()),UserState::Active).await {Ok(upd_u)=>{let mt=format!("Great, {}! Profile complete.\n\nMenu:\n/find_match\n/profile\n/help",escape_markdown_v2(upd_u.name.as_deref().unwrap_or_default()));Response::from_json!(&json!({"method":"sendMessage","chat_id":chat_id,"text":mt,"parse_mode":"MarkdownV2"}))}Err(_)=>Response::from_json!(&json!({"method":"sendMessage","chat_id":chat_id,"text":"Error saving name."}))}}else{Response::from_json!(&json!({"method":"sendMessage","chat_id":chat_id,"text":"Not sure what you mean."}))}}else{Response::from_json!(&json!({"method":"sendMessage","chat_id":chat_id,"text":"Please /start."}))}}else{Response::error("User info missing.",400)}}}

async fn handle_location_message( env: &Env, user_service: &UserService, _media_service: &MediaService, chat_id: i64, location: &TelegramLocation ) -> Result<Response> { if let Some(session)=get_profile_editing_session(env,chat_id).await?{let uid=session.user_id.clone();if matches!(session.step,CurrentEditingStep::AwaitingValue(EditingField::LocationText)){match user_service.update_user_location(&uid,None,Some(location.latitude),Some(location.longitude)).await{Ok(_)=>{clear_profile_editing_session(env,chat_id).await?;Response::from_json!(&json!({"method":"sendMessage","chat_id":chat_id,"text":format!("Location updated via pin \\(Lat: {:.3}, Lon: {:.3}\\)\\. /profile",location.latitude,location.longitude),"parse_mode":"MarkdownV2"}))}Err(e)=>{console_error!("Failed shared location update for {}: {}",uid,e);Response::from_json!(&json!({"method":"sendMessage","chat_id":chat_id,"text":"Error updating from pin\\. Try `cancel` or again\\."}))}}}else{Response::from_json!(&json!({"method":"sendMessage","chat_id":chat_id,"text":"Thanks for sharing\\! Not expecting location for profile edit now\\. Use `/profile edit` first\\." ,"parse_mode":"MarkdownV2"}))}}else{Response::from_json!(&json!({"method":"sendMessage","chat_id":chat_id,"text":"Thanks for sharing\\! To save to profile, use `/profile edit`\\.","parse_mode":"MarkdownV2"}))}}
async fn handle_media_message( env: &Env, user_service: &UserService, media_service: &MediaService, chat_id: i64, message: &TelegramMessage ) -> Result<Response> { let session_opt=get_profile_editing_session(env,chat_id).await?; if let Some(session)=session_opt{if session.step==CurrentEditingStep::AwaitingMediaFile{let uid=session.user_id.clone(); let u_check=user_service.get_user_by_id(&uid).await?.ok_or_else(||Error::RustError(format!("User {} not found",uid)))?; if u_check.media_keys.len()>=MAX_USER_MEDIA_ITEMS{clear_profile_editing_session(env,chat_id).await?;return Response::from_json!(&json!({"method":"sendMessage","chat_id":chat_id,"text":format!("Media limit ({}) reached\\.",MAX_USER_MEDIA_ITEMS),"parse_mode":"MarkdownV2"}));} let mut fid:Option<String>=None;let mut fname:Option<String>=None;let mut mime:Option<String>=None; if let Some(ref p)=message.photo{if let Some(lp)=p.iter().max_by_key(|ph|ph.width*ph.height){fid=Some(lp.file_id.clone());fname=Some(format!("{}.jpg",lp.file_unique_id));mime=Some("image/jpeg".to_string());}}else if let Some(ref v)=message.video{fid=Some(v.file_id.clone());fname=v.file_name.clone().or_else(||Some(format!("{}.mp4",v.file_unique_id)));mime=v.mime_type.clone();}else if let Some(ref d)=message.document{if let Some(m)=&d.mime_type{if m.starts_with("image/")||m.starts_with("video/"){fid=Some(d.file_id.clone());fname=d.file_name.clone();mime=d.mime_type.clone();}else{return Response::from_json!(&json!({"method":"sendMessage","chat_id":chat_id,"text":"Unsupported document type\\."}));}}else{return Response::from_json!(&json!({"method":"sendMessage","chat_id":chat_id,"text":"Could not determine file type\\."}));}} if let Some(file_id)=fid{let file_name_r2=fname.unwrap_or_else(||"uploaded_media".to_string());match download_telegram_file(env,&file_id).await{Ok(body)=>{match media_service.upload_media(&uid,file_name_r2,mime,body).await{Ok(r2k)=>{match user_service.add_media_key_to_user(&uid,r2k.clone()).await{Ok(_)=>{clear_profile_editing_session(env,chat_id).await?;Response::from_json!(&json!({"method":"sendMessage","chat_id":chat_id,"text":format!("Media added\\! Key: `{}`",escape_markdown_v2(&r2k)),"parse_mode":"MarkdownV2"}))}Err(e)=>{console_error!("Failed add media key {} to user {}: {}",r2k,uid,e);if let Err(del_e)=media_service.delete_media(&r2k).await{console_error!("CRITICAL: Orphaned R2 object {}: {}",r2k,del_e);}Response::from_json!(&json!({"method":"sendMessage","chat_id":chat_id,"text":"Error saving media to profile\\."}))}}}Err(e)=>{console_error!("R2 upload failed for {}: {}",uid,e);Response::from_json!(&json!({"method":"sendMessage","chat_id":chat_id,"text":"Error uploading media\\."}))}}}Err(e)=>{console_error!("Telegram download failed for {}: {}",uid,e);Response::from_json!(&json!({"method":"sendMessage","chat_id":chat_id,"text":"Error downloading media\\."}))}}}else{Response::from_json!(&json!({"method":"sendMessage","chat_id":chat_id,"text":"No supported media found\\."}))}}else{Response::from_json!(&json!({"method":"sendMessage","chat_id":chat_id,"text":"Not expecting media for profile edit now\\. Use `/profile add_media` first\\.","parse_mode":"MarkdownV2"}))}}else{Response::from_json!(&json!({"method":"sendMessage","chat_id":chat_id,"text":"To add media, use `/profile add_media` first\\.","parse_mode":"MarkdownV2"}))}}

async fn handle_profile_command( _user_service: &UserService, _rbac_service: &RBACService, _media_service: &MediaService, _env_config: &EnvironmentConfig, user: &DomainUser, chat_id: i64, _args: Vec<&str> ) -> Result<Response> { Response::from_json(&json!({ "method": "sendMessage", "chat_id": chat_id, "text": format_user_profile_view(user), "parse_mode": "MarkdownV2"})) }
async fn handle_find_match_command( _user_service: &UserService, _rbac_service: &RBACService, _media_service: &MediaService, _env_config: &EnvironmentConfig, user: &DomainUser, chat_id: i64, _args: Vec<&str> ) -> Result<Response> { Response::from_json(&json!({ "method": "sendMessage", "chat_id": chat_id, "text": "Looking for matches... (Placeholder - Feature coming soon!)" })) }
async fn handle_help_command( _user_service: &UserService, _rbac_service: &RBACService, _media_service: &MediaService, _env_config: &EnvironmentConfig, user: &DomainUser, chat_id: i64, _args: Vec<&str> ) -> Result<Response> { let user_name_escaped = escape_markdown_v2(user.name.as_deref().unwrap_or("there")); let mut help_text = format!("Hi {}!\n\nHere's how I can help:\n\n*/start* \\- Restart or main menu\\.\n*/profile* \\- View your profile\\.\n*/profile edit* \\- Start editing your profile\\.\n*/profile add_media* \\- Add a photo/video to your profile\\.\n*/profile delete_media* \\- Remove a photo/video from your profile\\.\n*/find_match* \\- Find a match\\.\n*/help* \\- This help message\\.\n\nMore features soon\\!", user_name_escaped); if user.roles.contains(&UserRole::Admin) { help_text.push_str("\n\n*Admin Commands:*\n/status \\- Check bot status\\."); } Response::from_json(&json!({ "method": "sendMessage", "chat_id": chat_id, "text": help_text, "parse_mode": "MarkdownV2" })) }
async fn handle_admin_status_command( _user_service: &UserService, _rbac_service: &RBACService, _media_service: &MediaService, _env_config: &EnvironmentConfig, user: &DomainUser, chat_id: i64, _args: Vec<&str> ) -> Result<Response> { Response::from_json(&json!({ "method": "sendMessage", "chat_id": chat_id, "text": "Bot status: Healthy\\! \\(Admin View\\)", "parse_mode": "MarkdownV2" })) }

async fn dispatch_command( env: &Env, user_service: &UserService, rbac_service: &RBACService, media_service: &MediaService, env_config: &EnvironmentConfig, telegram_user_opt: Option<TelegramUser>, chat_id: i64, text: &str ) -> Result<Response> {
    let mut parts = text.split_whitespace(); let command_str = parts.next().unwrap_or("").to_lowercase(); let args: Vec<&str> = parts.collect();
    let telegram_user = match telegram_user_opt { Some(tu) => tu, None => { return Response::from_json(&json!({"method": "sendMessage", "chat_id": chat_id, "text": "Cannot identify sender."})); } };
    let domain_user = match user_service.get_user_by_telegram_id(telegram_user.id).await? { Some(u) => u, None => { return Response::from_json(&json!({"method": "sendMessage", "chat_id": chat_id, "text": "Please use /start to begin."})); } };
    if !rbac_service.check_permission(&domain_user.roles, &command_str) { return Response::from_json(&json!({"method": "sendMessage", "chat_id": chat_id, "text": "You don't have permission for that."})); }
    match command_str.as_str() {
        "/profile" => {
            if args.first().map_or(false, |arg| arg.eq_ignore_ascii_case("edit")) { handle_profile_edit_initiate(env, &domain_user, chat_id).await }
            else if args.first().map_or(false, |arg| arg.eq_ignore_ascii_case("add_media")) { handle_profile_add_media_initiate(env, &domain_user, chat_id).await }
            else if args.first().map_or(false, |arg| arg.eq_ignore_ascii_case("delete_media")) { handle_profile_delete_media_initiate(env, user_service, &domain_user, chat_id).await }
            else if args.is_empty() { handle_profile_command(user_service, rbac_service, media_service, env_config, &domain_user, chat_id, args).await }
            else { Response::from_json(&json!({"method": "sendMessage", "chat_id": chat_id, "text": "Usage: `/profile`, `/profile edit`, `/profile add_media`, `/profile delete_media`\\." ,"parse_mode": "MarkdownV2"})) }
        }
        "/find_match" => handle_find_match_command(user_service, rbac_service, media_service, env_config, &domain_user, chat_id, args).await,
        "/help" => handle_help_command(user_service, rbac_service, media_service, env_config, &domain_user, chat_id, args).await,
        "/status" => { if domain_user.roles.contains(&UserRole::Admin) { handle_admin_status_command(user_service, rbac_service, media_service, env_config, &domain_user, chat_id, args).await } else { Response::from_json(&json!({"method": "sendMessage", "chat_id": chat_id, "text": "Admin only."})) } }
        _ => Response::from_json(&json!({"method": "sendMessage", "chat_id": chat_id, "text": format!("Unknown command: {}. Try /help.", command_str)}))
    }
}

async fn handle_start_command( user_service: &UserService, rbac_service: &RBACService, _media_service: &MediaService, env_config: &EnvironmentConfig, telegram_user_opt: Option<TelegramUser>, chat_id: i64 ) -> Result<Response> { let tu=match telegram_user_opt{Some(t)=>t,None=>{return Response::from_json!(&json!({"method":"sendMessage","chat_id":chat_id,"text":"Cannot identify you."}));}};match user_service.get_user_by_telegram_id(tu.id).await{Ok(Some(du))=>{if du.state==UserState::Blocked{return Response::from_json!(&json!({"method":"sendMessage","chat_id":chat_id,"text":"Blocked."}));}if !rbac_service.check_permission(&du.roles,"/start"){return Response::from_json!(&json!({"method":"sendMessage","chat_id":chat_id,"text":"Access denied."}));}if du.is_profile_complete(){let m=format!("Welcome back, {}!\n\nMenu:\n/find_match\n/profile\n/help",escape_markdown_v2(du.name.as_deref().unwrap_or("there")));return Response::from_json!(&json!({"method":"sendMessage","chat_id":chat_id,"text":m,"parse_mode":"MarkdownV2"}));}else{if du.name.is_none(){return Response::from_json!(&json!({"method":"sendMessage","chat_id":chat_id,"text":"Welcome! What's your name?"}));}else{match user_service.update_user_state_and_name(du.id.clone(),du.name.clone(),UserState::Active).await{Ok(u)=>{let mt=format!("Thanks, {}! Profile active.\n\nMenu:\n/find_match\n/profile\n/help",escape_markdown_v2(u.name.as_deref().unwrap_or_default()));Response::from_json!(&json!({"method":"sendMessage","chat_id":chat_id,"text":mt,"parse_mode":"MarkdownV2"}))}Err(_)=>Response::from_json!(&json!({"method":"sendMessage","chat_id":chat_id,"text":"Error activating."}))}}}}Ok(None)=>{match user_service.create_user_from_telegram_user(&tu).await{Ok(nu)=>{if !rbac_service.check_permission(&nu.roles,"/start"){return Response::from_json!(&json!({"method":"sendMessage","chat_id":chat_id,"text":"Permission error."}));}Response::from_json!(&json!({"method":"sendMessage","chat_id":chat_id,"text":"Welcome! What's your name?"}))}Err(_)=>Response::from_json!(&json!({"method":"sendMessage","chat_id":chat_id,"text":"Creation failed."}))}}Err(_)=>Response::from_json!(&json!({"method":"sendMessage","chat_id":chat_id,"text":"DB error."}))}}

#[event(fetch)]
pub async fn main(mut req: Request, env: Env, _ctx: worker::Context) -> Result<Response> {
    utils::set_panic_hook();
    let method = req.method();

    if method != Method::Post {
        return Response::error("Webhook only accepts POST requests.", 405);
    }

    // --- Existing Webhook Logic (POST requests) ---
    let config_service = ConfigService::new();
    let env_config = match config_service.get_environment_config(&env).await { Ok(c) => c, Err(_) => EnvironmentConfig::default() };

    let update: TelegramUpdate = match req.json().await { Ok(u) => u, Err(e) => {
        console_error!("[Main] Failed to parse JSON update: {}", e);
        return Response::error(format!("Bad request: {}.", e), 400);
    }};

    let mut final_response: Result<Response> = Response::empty()?.with_status(200);
    let mut user_internal_id_for_interaction_update: Option<String> = None;

    if let Some(message) = update.message {
        let chat_id = message.chat.id;
        let telegram_user_opt = message.from.clone();
        let user_service = match UserService::new(&env){Ok(s)=>s,Err(_)=>{return Response::from_json!(&json!({"method":"sendMessage","chat_id":chat_id,"text":"Internal error."}));}};
        let rbac_service = RBACService::new();
        let media_service = match MediaService::new(&env){Ok(s)=>s,Err(_)=>{return Response::from_json!(&json!({"method":"sendMessage","chat_id":chat_id,"text":"Media service error."}));}};

        if let Some(ref tu) = telegram_user_opt { if let Ok(Some(user)) = user_service.get_user_by_telegram_id(tu.id).await { user_internal_id_for_interaction_update = Some(user.id.clone()); } }

        if message.photo.is_some() || message.video.is_some() || message.document.is_some() {
            final_response = handle_media_message(&env, &user_service, &media_service, chat_id, &message).await;
        } else if let Some(ref loc) = message.location {
            final_response = handle_location_message(&env, &user_service, &media_service, chat_id, loc).await;
        } else if let Some(text) = message.text {
            let text_trimmed = text.trim();
            if text_trimmed.starts_with("/start") {
                final_response = handle_start_command(&user_service, &rbac_service, &media_service, &env_config, telegram_user_opt.clone(), chat_id).await;
            } else if text_trimmed.starts_with("/") {
                final_response = dispatch_command(&env, &user_service, &rbac_service, &media_service, &env_config, telegram_user_opt.clone(), chat_id, &text_trimmed).await;
            } else {
                final_response = handle_text_message(&env, &user_service, &media_service, &env_config, telegram_user_opt.clone(), chat_id, &text_trimmed).await;
            }
        } else {
            final_response = Ok(Response::from_json(&json!({"method": "sendMessage", "chat_id": chat_id, "text": "I can only understand text, locations, photos, or videos."}))?);
        }

        if user_internal_id_for_interaction_update.is_none() { if let Some(ref tu) = telegram_user_opt { if let Ok(Some(user)) = user_service.get_user_by_telegram_id(tu.id).await { user_internal_id_for_interaction_update = Some(user.id.clone()); } } }
        if let Some(user_id) = user_internal_id_for_interaction_update { if let Err(e) = user_service.record_user_interaction(&user_id).await { console_error!("[Main] Failed record interaction {}: {}", user_id, e); }}
    } else {
        console_log!("[Main] Received update without a message. Ignoring.");
    }
    final_response
}

// --- Tests for lib.rs ---
#[cfg(test)]
mod lib_tests {
    use super::*;
    use crate::user_service::{User as DomainUser, UserState, default_user_roles, default_media_keys};
    use crate::rbac_service::Role as UserTestRole;
    use chrono::{TimeZone, Utc};
    use serde_json;

    fn create_domain_user_for_lib_test( name: Option<String>, age: Option<u8>, gender: Option<String>, bio: Option<String>, location_text: Option<String>, latitude: Option<f64>, longitude: Option<f64>, media_keys: Vec<String>, state: UserState, roles: Vec<UserTestRole>, created_at_str: &str, last_interaction_at_str: &str ) -> DomainUser { DomainUser { id: "domain_user_test_id".to_string(), telegram_id: 123456, telegram_username: Some("libtester".to_string()), name, age, gender, bio, location_text, latitude, longitude, media_keys, created_at: Utc.datetime_from_str(created_at_str, "%Y-%m-%dT%H:%M:%SZ").unwrap(), updated_at: Utc.datetime_from_str(last_interaction_at_str, "%Y-%m-%dT%H:%M:%SZ").unwrap(), last_interaction_at: Utc.datetime_from_str(last_interaction_at_str, "%Y-%m-%dT%H:%M:%SZ").unwrap(), state, roles, } }

    #[test]
    fn test_escape_markdown_v2_common_chars() { /* ... */ }
    #[test]
    fn test_format_user_profile_view_all_fields_with_markdown_chars() { /* ... */ }
    #[test]
    fn test_format_user_profile_view_some_fields_none() { /* ... */ }
    #[test]
    fn test_format_user_profile_location_variants_formatting() { /* ... */ }
    #[test]
    fn test_format_user_profile_empty_bio_and_name() { /* ... */ }

    // Note: `validation_tests` mod is already within `lib_tests` from previous step if that was the structure.
    // If it's a separate sibling mod to `lib_tests`, then this is fine.
    // Assuming it's a sibling for now based on the file structure.
    // If it was meant to be nested, the `mod validation_tests` line would be inside `mod lib_tests`.
    // Based on previous step, it should be nested. Let's ensure that structure.
    // The current file overwrite will place it as a sibling if not careful.
    // The prompt wants `#[cfg(test)] mod validation_tests { ... }` in `src/lib.rs` (or `src/validation.rs`).
    // And `#[cfg(test)] mod lib_tests { ... }` in `src/lib.rs`.
    // So they are sibling test modules.

    #[cfg(test)]
    mod validation_tests { use super::*; #[test]fn test_validate_name_valid(){assert!(validate_name("John Doe").is_ok());assert!(validate_name("J").is_ok());assert!(validate_name(&"a".repeat(MAX_NAME_LEN)).is_ok());}#[test]fn test_validate_name_invalid(){assert_eq!(validate_name("").unwrap_err(),ValidationError::TooShort(MIN_NAME_LEN));assert_eq!(validate_name("   ").unwrap_err(),ValidationError::TooShort(MIN_NAME_LEN));assert_eq!(validate_name(&"a".repeat(MAX_NAME_LEN+1)).unwrap_err(),ValidationError::TooLong(MAX_NAME_LEN));}#[test]fn test_validate_age_valid(){assert_eq!(validate_age("25").unwrap(),25);assert_eq!(validate_age(&MIN_AGE.to_string()).unwrap(),MIN_AGE);assert_eq!(validate_age(&MAX_AGE.to_string()).unwrap(),MAX_AGE);}#[test]fn test_validate_age_invalid(){assert_eq!(validate_age("abc").unwrap_err().to_string(),ValidationError::InvalidFormat("Age must be a number.".to_string()).to_string());assert_eq!(validate_age(&(MIN_AGE-1).to_string()).unwrap_err(),ValidationError::OutOfRange{min:MIN_AGE.to_string(),max:MAX_AGE.to_string()});assert_eq!(validate_age(&(MAX_AGE+1).to_string()).unwrap_err(),ValidationError::OutOfRange{min:MIN_AGE.to_string(),max:MAX_AGE.to_string()});assert_eq!(validate_age(" 12 ").unwrap_err(),ValidationError::OutOfRange{min:MIN_AGE.to_string(),max:MAX_AGE.to_string()});}#[test]fn test_validate_gender(){assert!(validate_gender("Male").is_ok());assert!(validate_gender("").is_ok());assert!(validate_gender(&"a".repeat(MAX_GENDER_LEN)).is_ok());assert_eq!(validate_gender(&"a".repeat(MAX_GENDER_LEN+1)).unwrap_err(),ValidationError::TooLong(MAX_GENDER_LEN));}#[test]fn test_validate_bio(){assert!(validate_bio("This is a bio.").is_ok());assert!(validate_bio("").is_ok());assert!(validate_bio(&"b".repeat(MAX_BIO_LEN)).is_ok());assert_eq!(validate_bio(&"b".repeat(MAX_BIO_LEN+1)).unwrap_err(),ValidationError::TooLong(MAX_BIO_LEN));}#[test]fn test_validate_location_text(){assert!(validate_location_text("City, Country").is_ok());assert!(validate_location_text("").is_ok());assert!(validate_location_text("  ").is_ok());assert!(validate_location_text(&"l".repeat(MAX_LOCATION_TEXT_LEN)).is_ok());assert_eq!(validate_location_text(&"l".repeat(MAX_LOCATION_TEXT_LEN+1)).unwrap_err(),ValidationError::TooLong(MAX_LOCATION_TEXT_LEN));}}

    #[test]
    fn test_deserialize_telegram_message_with_photo() { /* ... */ }
    #[test]
    fn test_deserialize_telegram_message_with_video() { /* ... */ }
    #[test]
    fn test_deserialize_telegram_message_with_document() { /* ... */ }
    #[test]
    fn test_deserialize_telegram_message_with_location() { /* ... */ }
    #[test]
    fn test_deserialize_telegram_getfile_response() { /* ... */ }
}
