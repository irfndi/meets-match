mod utils;
mod config_service;
mod monitoring_service;
mod security_service;
mod user_service;
mod matching_service;
mod communication_service;
mod analytics_service;
mod notification_service;
mod rbac_service;
pub mod media_service;

use worker::*;
use serde::{Deserialize, Serialize};
use serde_json::json;

use config_service::{ConfigService, EnvironmentConfig};
use user_service::{UserService, User as DomainUser, UserState, MAX_USER_MEDIA_ITEMS};
use rbac_service::{RBACService, Role as UserRole};
use media_service::MediaService;
use chrono::{DateTime, Duration, Utc};


// --- Telegram Type Definitions ---
#[derive(Deserialize, Debug, Clone)] pub struct TelegramLocation { pub latitude: f64, pub longitude: f64 }
#[derive(Deserialize, Debug, Clone)] pub struct TelegramPhotoSize { pub file_id: String, pub file_unique_id: String, pub width: u32, pub height: u32, pub file_size: Option<u32> }
#[derive(Deserialize, Debug, Clone)] pub struct TelegramVideo { pub file_id: String, pub file_unique_id: String, pub width: u32, pub height: u32, pub duration: u32, pub mime_type: Option<String>, pub file_name: Option<String>, pub file_size: Option<u32> }
#[derive(Deserialize, Debug, Clone)] pub struct TelegramDocument { pub file_id: String, pub file_unique_id: String, pub file_name: Option<String>, pub mime_type: Option<String>, pub file_size: Option<u32> }
#[derive(Deserialize, Debug, Clone)] pub struct TelegramMessage { pub message_id: i64, pub from: Option<TelegramUser>, pub chat: TelegramChat, pub date: i64, pub text: Option<String>, pub location: Option<TelegramLocation>, pub photo: Option<Vec<TelegramPhotoSize>>, pub video: Option<TelegramVideo>, pub document: Option<TelegramDocument> }
#[derive(Deserialize, Debug)] pub struct TelegramUpdate { pub message: Option<TelegramMessage> }
#[derive(Deserialize, Debug, Clone)] pub struct TelegramUser { pub id: i64, pub username: Option<String> }
#[derive(Deserialize, Debug, Clone)] pub struct TelegramChat { pub id: i64 }
#[derive(Deserialize, Debug)] pub struct TelegramFile { pub file_size: Option<u64>, pub file_path: Option<String> } // file_id and file_unique_id are not always present in the "result" of getFile
#[derive(Deserialize, Debug)] pub struct TelegramApiResponse<T> { pub ok: bool, pub result: Option<T>, pub description: Option<String>, pub error_code: Option<i32> }
// --- End of Telegram Type Definitions ---

// --- Profile Editing Session Types ---
#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)] pub enum EditingField { Name, Age, Gender, Bio, LocationText }
#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)] pub enum CurrentEditingStep { SelectingField, AwaitingValue(EditingField), AwaitingMediaFile, AwaitingMediaDeletionChoice(Vec<String>) }
#[derive(Serialize, Deserialize, Debug, Clone)] pub struct ProfileEditingSession { pub user_id: String, pub chat_id: i64, pub step: CurrentEditingStep, pub prompted_at: DateTime<Utc> }
const PROFILE_EDIT_SESSION_KEY_PREFIX: &str = "profile_edit_session_v1:";
// --- End Profile Editing Session Types ---

// --- KV Helper Functions ---
fn get_session_kv(env: &Env) -> Result<KvStore> { env.kv("SESSIONS_KV") }
fn format_session_key(chat_id: i64) -> String { format!("{}{}", PROFILE_EDIT_SESSION_KEY_PREFIX, chat_id) }
async fn set_profile_editing_session(env: &Env, session: &ProfileEditingSession) -> Result<()> { let store = get_session_kv(env)?; let key = format_session_key(session.chat_id); let session_json = serde_json::to_string(session).map_err(|e| worker::Error::RustError(format!("Serialization error: {}", e)))?; store.put_with_options(&key, session_json)?.expiration_ttl(900).execute().await?; Ok(()) }
async fn get_profile_editing_session(env: &Env, chat_id: i64) -> Result<Option<ProfileEditingSession>> { match get_session_kv(env) { Ok(store) => { let key = format_session_key(chat_id); match store.get(&key).json::<ProfileEditingSession>().await { Ok(Some(s)) => Ok(Some(s)), Ok(None) => Ok(None), Err(e) => { let es = e.to_string(); if es.contains("deserialize") || es.contains("invalid type") { console_warn!("[KV] Corrupt session for {}: {}. Deleting.", chat_id, es); if let Err(de) = store.delete(&key).await { console_error!("[KV] Failed delete corrupt key {}: {}", key, de); } Ok(None) } else { console_error!("[KV] Error get session {}: {}", chat_id, es); Err(e) } } } } Err(e) => { console_error!("[KV] CRITICAL: Failed get SESSIONS_KV store: {}. Check wrangler.toml.", e); Err(e) } } }
async fn clear_profile_editing_session(env: &Env, chat_id: i64) -> Result<()> { match get_session_kv(env) { Ok(store) => { store.delete(&format_session_key(chat_id)).await?; console_log!("[KV] Cleared session for chat_id {}", chat_id); Ok(()) } Err(e) => { console_error!("[KV] CRITICAL: Failed get SESSIONS_KV for delete: {}. Check wrangler.toml.", e); Err(e) } } }
// --- End KV Helper Functions ---

// --- Validation Logic ---
#[derive(Debug, PartialEq)] pub enum ValidationError { TooShort(usize), TooLong(usize), InvalidFormat(String), OutOfRange { min: String, max: String } }
impl ToString for ValidationError { fn to_string(&self) -> String { match self { ValidationError::TooShort(min) => format!("Input too short\\. Min length {}\\.", min), ValidationError::TooLong(max) => format!("Input too long\\. Max length {}\\.", max), ValidationError::InvalidFormat(reason) => escape_markdown_v2(reason), ValidationError::OutOfRange{ min, max } => format!("Value out of range\\. Must be {} - {}\\.", min, max), } } }
const MIN_NAME_LEN: usize = 1; const MAX_NAME_LEN: usize = 50; const MIN_AGE: u8 = 13; const MAX_AGE: u8 = 99; const MAX_GENDER_LEN: usize = 50; const MIN_GENDER_LEN: usize = 0; const MAX_BIO_LEN: usize = 250; const MAX_LOCATION_TEXT_LEN: usize = 100;
pub fn validate_name(name: &str) -> Result<(), ValidationError> { let t=name.trim(); if t.len()<MIN_NAME_LEN{Err(ValidationError::TooShort(MIN_NAME_LEN))}else if t.len()>MAX_NAME_LEN{Err(ValidationError::TooLong(MAX_NAME_LEN))}else{Ok(())}}
pub fn validate_age(age_str: &str) -> Result<u8, ValidationError> { match age_str.trim().parse::<u8>(){Ok(v)if v>=MIN_AGE&&v<=MAX_AGE=>Ok(v), Ok(age_val)=>Err(ValidationError::OutOfRange{min:MIN_AGE.to_string(),max:MAX_AGE.to_string()}),Err(_)=>Err(ValidationError::InvalidFormat("Age must be a number.".to_string()))}}
pub fn validate_gender(gender: &str) -> Result<(), ValidationError> { let t=gender.trim(); if t.len()<MIN_GENDER_LEN&& !t.is_empty(){Err(ValidationError::TooShort(MIN_GENDER_LEN))}else if t.len()>MAX_GENDER_LEN{Err(ValidationError::TooLong(MAX_GENDER_LEN))}else{Ok(())}}
pub fn validate_bio(bio: &str) -> Result<(), ValidationError> { let t=bio.trim(); if t.len()>MAX_BIO_LEN{Err(ValidationError::TooLong(MAX_BIO_LEN))}else{Ok(())}}
pub fn validate_location_text(loc: &str) -> Result<(), ValidationError> { let t=loc.trim(); if t.is_empty(){Ok(())}else if t.len()>MAX_LOCATION_TEXT_LEN{Err(ValidationError::TooLong(MAX_LOCATION_TEXT_LEN))}else{Ok(())}}
// --- End Validation Logic ---

// --- Formatting & Parsing Helpers ---
fn escape_markdown_v2(text: &str) -> String { let s = r#"_*[]()~`>#+-=|{}.!"#; let mut o = String::new(); for c in text.chars() { if s.contains(c) { o.push('\\'); } o.push(c); } o }
fn format_user_profile_view(user: &DomainUser) -> String { let n=user.name.as_deref().map_or_else(||"Not set".to_string(),escape_markdown_v2); let a=user.age.map_or("Not set".to_string(),|v|v.to_string()); let g=user.gender.as_deref().map_or_else(||"Not set".to_string(),escape_markdown_v2); let b=user.bio.as_deref().map_or_else(||"Not set".to_string(),escape_markdown_v2); let l=match(&user.location_text,user.latitude,user.longitude){(Some(t),Some(lt),Some(ln))=>format!("{} \\(Lat: {:.3}, Lon: {:.3}\\)",escape_markdown_v2(t),lt,ln),(Some(t),_,_)=>escape_markdown_v2(t),(None,Some(lt),Some(ln))=>format!("Lat: {:.3}, Lon: {:.3}",lt,ln),_=>"Not set".to_string()}; let mc=user.media_keys.len(); let mut mls=String::new(); if !user.media_keys.is_empty(){for(i,_)in user.media_keys.iter().enumerate(){mls.push_str(&format!("\n  {}\\. Media Item {}",i+1,i+1));}} let m_sec=if user.media_keys.is_empty(){format!("{} item\\(s\\)",mc)}else{format!("{} item\\(s\\){}",mc,mls)}; format!("*Your Profile*\n\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\nðŸ·ï¸ *Name*: {}\nðŸŽ‚ *Age*: {}\nðŸ‘¤ *Gender*: {}\nðŸ“ *Bio*: {}\nðŸ“ *Location*: {}\nðŸ–¼ï¸ *Media Items*: {}\n\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\n*Technical Info:*\nTelegram ID: `{}`\nUser ID: `{}`\nRoles: `{:?}`\nState: `{:?}`\nJoined: `{}`\nLast Interaction: `{}`\n\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\nTo edit, use `/profile edit`\\.\nTo add media, use `/profile add_media`\\.\nTo delete media, use `/profile delete_media` \\(soon\\!\\)\\.",n,a,g,b,l,m_sec,user.telegram_id,user.id,user.roles,user.state,user.created_at.format("%Y-%m-%d %H:%M UTC"),user.last_interaction_at.format("%Y-%m-%d %H:%M UTC"))}
fn parse_editing_field_choice(text: &str) -> Option<EditingField> { match text.trim().to_lowercase().as_str() { "name"=>Some(EditingField::Name),"age"=>Some(EditingField::Age),"gender"=>Some(EditingField::Gender),"bio"=>Some(EditingField::Bio),"location"=>Some(EditingField::LocationText),_=>None } }
// --- End Formatting & Parsing Helpers ---

// --- Telegram File Download Helper ---
async fn download_telegram_file(env: &Env, file_id: &str) -> Result<Vec<u8>> { /* ... */ let bot_token=env.secret("TELEGRAM_TOKEN")?.to_string();let get_file_url_str=format!("https://api.telegram.org/bot{}/getFile?file_id={}",bot_token,file_id);let get_file_url=get_file_url_str.parse()?;let mut response=Fetch::Url(get_file_url).send().await?;if response.status_code()!=200{let body=response.text().await.unwrap_or_default();console_error!("[TelegramDL] getFile API error {}: {}",response.status_code(),body);return Err(Error::RustError(format!("Telegram getFile API error: {}",response.status_code())));}let file_api_response:TelegramApiResponse<TelegramFile>=response.json().await.map_err(|e|{console_error!("[TelegramDL] Failed to parse getFile JSON response: {}",e);Error::RustError(format!("Telegram getFile JSON parse error: {}",e))})?;if !file_api_response.ok||file_api_response.result.is_none()||file_api_response.result.as_ref().unwrap().file_path.is_none(){console_error!("[TelegramDL] Telegram getFile API call not OK or missing file_path: {:?}",file_api_response.description);return Err(Error::RustError("Failed to get file path from Telegram".to_string()));}let file_path=file_api_response.result.unwrap().file_path.unwrap();let file_download_url_str=format!("https://api.telegram.org/file/bot{}/{}",bot_token,file_path);let file_download_url=file_download_url_str.parse()?;let mut file_response=Fetch::Url(file_download_url).send().await?;if file_response.status_code()!=200{let body=file_response.text().await.unwrap_or_default();console_error!("[TelegramDL] File download error {}: {}",file_response.status_code(),body);return Err(Error::RustError(format!("Telegram file download error: {}",file_response.status_code())));}file_response.bytes().await.map_err(|e|Error::RustError(format!("Failed to read file bytes: {}",e)))}
// --- End Telegram File Download Helper ---

// --- Command & Message Handlers ---
async fn handle_profile_edit_initiate( env: &Env, user: &DomainUser, chat_id: i64 ) -> Result<Response> { /* ... */ let s = ProfileEditingSession { user_id: user.id.clone(), chat_id, step: CurrentEditingStep::SelectingField, prompted_at: Utc::now() }; match set_profile_editing_session(env, &s).await { Ok(_) => { let pt = "Okay, let's edit your profile\\.\n\nWhich field would you like to change\\?\nChoose from: `Name`, `Age`, `Gender`, `Bio`, `Location`\\.\n\nType your choice \\(e\\.g\\., 'Name'\\), or type `cancel` to abort\\."; Response::from_json(&json!({ "method": "sendMessage", "chat_id": chat_id, "text": pt, "parse_mode": "MarkdownV2" })) } Err(e) => { console_error!("[ProfileEdit] Failed to set session for {}: {}", user.id, e); Response::from_json(&json!({ "method": "sendMessage", "chat_id": chat_id, "text": "Error starting edit process\\. Try again\\." })) } } }
async fn handle_profile_add_media_initiate( env: &Env, user: &DomainUser, chat_id: i64 ) -> Result<Response> { /* ... */ if user.media_keys.len()>=MAX_USER_MEDIA_ITEMS{return Response::from_json!(&json!({"method":"sendMessage","chat_id":chat_id,"text":format!("Max {} media items reached\\.",MAX_USER_MEDIA_ITEMS),"parse_mode":"MarkdownV2"}));} let ns=ProfileEditingSession{user_id:user.id.clone(),chat_id,step:CurrentEditingStep::AwaitingMediaFile,prompted_at:Utc::now()}; match set_profile_editing_session(env,&ns).await{Ok(_)=>Response::from_json!(&json!({"method":"sendMessage","chat_id":chat_id,"text":"Send photo/video (max 20MB), or `cancel`\\.","parse_mode":"MarkdownV2"})),Err(e)=>{console_error!("Failed set AwaitingMediaFile session {}: {}",user.id,e);Response::from_json!(&json!({"method":"sendMessage","chat_id":chat_id,"text":"Error preparing media upload."}))}}}
async fn handle_profile_delete_media_initiate( env: &Env, _user_service: &UserService, user: &DomainUser, chat_id: i64 ) -> Result<Response> { /* ... */ if user.media_keys.is_empty(){return Response::from_json!(&json!({"method":"sendMessage","chat_id":chat_id,"text":"No media to delete\\. Use `/profile add_media`\\.","parse_mode":"MarkdownV2"}));}let mut list="Delete which media\\?\n\n".to_string();for(i,k)in user.media_keys.iter().enumerate(){let fname=k.split('/').last().unwrap_or("file");list.push_str(&format!("{}\\. `{}`\n",i+1,escape_markdown_v2(fname)));}list.push_str("\nReply with number, or `cancel`\\.");let ns=ProfileEditingSession{user_id:user.id.clone(),chat_id,step:CurrentEditingStep::AwaitingMediaDeletionChoice(user.media_keys.clone()),prompted_at:Utc::now()};match set_profile_editing_session(env,&ns).await{Ok(_)=>Response::from_json!(&json!({"method":"sendMessage","chat_id":chat_id,"text":list,"parse_mode":"MarkdownV2"})),Err(e)=>{console_error!("Failed set AwaitingMediaDeletionChoice session {}: {}",user.id,e);Response::from_json!(&json!({"method":"sendMessage","chat_id":chat_id,"text":"Error starting media deletion."}))}}}

async fn handle_text_message( env: &Env, user_service: &UserService, _env_config: &EnvironmentConfig, telegram_user_opt: Option<TelegramUser>, chat_id: i64, text: &str ) -> Result<Response> { /* ... */ if let Some(session)=get_profile_editing_session(env,chat_id).await?{let uid_session=session.user_id.clone();if text.eq_ignore_ascii_case("cancel"){clear_profile_editing_session(env,chat_id).await?;return Response::from_json!(&json!({"method":"sendMessage","chat_id":chat_id,"text":"Profile edit cancelled."}));}match session.step{CurrentEditingStep::SelectingField=>{if let Some(cf)=parse_editing_field_choice(text){let mut us=session.clone();us.step=CurrentEditingStep::AwaitingValue(cf.clone());us.prompted_at=Utc::now();set_profile_editing_session(env,&us).await?;let uo=user_service.get_user_by_id(&session.user_id).await?;let cvp=if let Some(ref u)=uo{match cf{EditingField::Name=>format!("\\(Current: {}\\)",escape_markdown_v2(u.name.as_deref().unwrap_or("Not set"))),EditingField::Age=>format!("\\(Current: {}\\)",u.age.map_or("Not set".to_string(),|a|a.to_string())),EditingField::Gender=>format!("\\(Current: {}\\)",escape_markdown_v2(u.gender.as_deref().unwrap_or("Not set"))),EditingField::Bio=>format!("\\(Current: {}\\)",escape_markdown_v2(u.bio.as_deref().unwrap_or("Not set"))),EditingField::LocationText=>{let lt=match(&u.location_text,u.latitude,u.longitude){(Some(t),_,_)=>escape_markdown_v2(t),(None,Some(lat),Some(lon))=>format!("Coordinates \\({:.3}, {:.3}\\)",lat,lon),_=>"Not set".to_string()};format!("\\(Current: {}\\)",lt)}}}else{"".to_string()};let pt=match cf{EditingField::Name=>format!("New Name? {}",cvp),EditingField::Age=>format!("New Age (13-99)? {}",cvp),EditingField::Gender=>format!("New Gender? {}",cvp),EditingField::Bio=>format!("New Bio (max 250 chars)? {}",cvp),EditingField::LocationText=>format!("New Location text (max 100 chars)? {}",cvp),};Response::from_json!(&json!({"method":"sendMessage","chat_id":chat_id,"text":pt,"parse_mode":"MarkdownV2"}))}else{Response::from_json!(&json!({"method":"sendMessage","chat_id":chat_id,"text":"Invalid choice\\. Use `Name`, `Age`, etc\\., or `cancel`\\.","parse_mode":"MarkdownV2"}))}}CurrentEditingStep::AwaitingValue(ref f)=>{let nvt=text.trim();match f{EditingField::Name=>match validate_name(nvt){Ok(_)=>match user_service.update_user_name(&uid_session,nvt.to_string()).await{Ok(u)=>{clear_profile_editing_session(env,chat_id).await?;Response::from_json!(&json!({"method":"sendMessage","chat_id":chat_id,"text":format!("Name updated: {}\\. /profile",escape_markdown_v2(u.name.as_deref().unwrap_or_default())),"parse_mode":"MarkdownV2"}))}Err(e)=>{console_error!("Err updating name for {}: {}",uid_session,e);Response::from_json!(&json!({"method":"sendMessage","chat_id":chat_id,"text":"Error updating name. Try `cancel` or again."}))}}Err(ve)=>Response::from_json!(&json!({"method":"sendMessage","chat_id":chat_id,"text":format!("Invalid name: {}\\. Try again or `cancel`\\.",ve.to_string()),"parse_mode":"MarkdownV2"}))}EditingField::Age=>match validate_age(nvt){Ok(age)=>match user_service.update_user_age(&uid_session,age).await{Ok(u)=>{clear_profile_editing_session(env,chat_id).await?;Response::from_json!(&json!({"method":"sendMessage","chat_id":chat_id,"text":format!("Age updated: {}\\. /profile",u.age.unwrap_or(0))}))}Err(e)=>{console_error!("Err updating age for {}: {}",uid_session,e);Response::from_json!(&json!({"method":"sendMessage","chat_id":chat_id,"text":"Error updating age. Try `cancel` or again."}))}}Err(ve)=>Response::from_json!(&json!({"method":"sendMessage","chat_id":chat_id,"text":format!("Invalid age: {}\\. Try again or `cancel`\\.",ve.to_string()),"parse_mode":"MarkdownV2"}))}EditingField::Gender=>match validate_gender(nvt){Ok(_)=>match user_service.update_user_gender(&uid_session,nvt.to_string()).await{Ok(u)=>{clear_profile_editing_session(env,chat_id).await?;Response::from_json!(&json!({"method":"sendMessage","chat_id":chat_id,"text":format!("Gender updated: {}\\. /profile",escape_markdown_v2(u.gender.as_deref().unwrap_or_default())),"parse_mode":"MarkdownV2"}))}Err(e)=>{console_error!("Err updating gender for {}: {}",uid_session,e);Response::from_json!(&json!({"method":"sendMessage","chat_id":chat_id,"text":"Error updating gender. Try `cancel` or again."}))}}Err(ve)=>Response::from_json!(&json!({"method":"sendMessage","chat_id":chat_id,"text":format!("Invalid gender: {}\\. Try again or `cancel`\\.",ve.to_string()),"parse_mode":"MarkdownV2"}))}EditingField::Bio=>match validate_bio(nvt){Ok(_)=>match user_service.update_user_bio(&uid_session,nvt.to_string()).await{Ok(_)=>{clear_profile_editing_session(env,chat_id).await?;Response::from_json!(&json!({"method":"sendMessage","chat_id":chat_id,"text":"Bio updated\\. /profile","parse_mode":"MarkdownV2"}))}Err(e)=>{console_error!("Err updating bio for {}: {}",uid_session,e);Response::from_json!(&json!({"method":"sendMessage","chat_id":chat_id,"text":"Error updating bio. Try `cancel` or again."}))}}Err(ve)=>Response::from_json!(&json!({"method":"sendMessage","chat_id":chat_id,"text":format!("Invalid bio: {}\\. Try again or `cancel`\\.",ve.to_string()),"parse_mode":"MarkdownV2"}))}EditingField::LocationText=>match validate_location_text(nvt){Ok(_)=>match user_service.update_user_location(&uid_session,Some(nvt.to_string()),None,None).await{Ok(u)=>{clear_profile_editing_session(env,chat_id).await?;Response::from_json!(&json!({"method":"sendMessage","chat_id":chat_id,"text":format!("Location text updated: {}\\. /profile",escape_markdown_v2(u.location_text.as_deref().unwrap_or_default())),"parse_mode":"MarkdownV2"}))}Err(e)=>{console_error!("Err updating location text for {}: {}",uid_session,e);Response::from_json!(&json!({"method":"sendMessage","chat_id":chat_id,"text":"Error updating location. Try `cancel` or again."}))}}Err(ve)=>Response::from_json!(&json!({"method":"sendMessage","chat_id":chat_id,"text":format!("Invalid location: {}\\. Try again or `cancel`\\.",ve.to_string()),"parse_mode":"MarkdownV2"}))}}}}CurrentEditingStep::AwaitingMediaFile=>{Response::from_json!(&json!({"method":"sendMessage","chat_id":chat_id,"text":"Please send a photo/video, or type `cancel`."}))}CurrentEditingStep::AwaitingMediaDeletionChoice(ref displayed_keys)=>{match text.trim().parse::<usize>(){Ok(num)if num>0&&num<=displayed_keys.len()=>{let key_to_del=&displayed_keys[num-1];let media_svc=match MediaService::new(env){Ok(ms)=>ms,Err(e)=>{console_error!("Failed init MediaService in AwaitingMediaDeletionChoice: {}",e);return Response::from_json!(&json!({"method":"sendMessage","chat_id":chat_id,"text":"Error processing. Try again."}));}};match media_svc.delete_media(key_to_del).await{Ok(_)=>{match user_service.remove_media_key_from_user(&uid_session,key_to_del).await{Ok(_)=>{clear_profile_editing_session(env,chat_id).await?;Response::from_json!(&json!({"method":"sendMessage","chat_id":chat_id,"text":format!("Media item `{}` deleted.",escape_markdown_v2(key_to_del.split('/').last().unwrap_or("file"))),"parse_mode":"MarkdownV2"}))}Err(e)=>{console_error!("Failed remove media key {} from D1 for {}: {}",key_to_del,uid_session,e);clear_profile_editing_session(env,chat_id).await?;Response::from_json!(&json!({"method":"sendMessage","chat_id":chat_id,"text":"Media deleted from storage, but profile update failed. Check /profile."}))}}}Err(e)=>{console_error!("Failed R2 delete for key {}: {}",key_to_del,e);Response::from_json!(&json!({"method":"sendMessage","chat_id":chat_id,"text":"Could not delete from storage. Try again or `cancel`."}))}}} _=>Response::from_json!(&json!({"method":"sendMessage","chat_id":chat_id,"text":"Invalid selection number. Try again or `cancel`."}))}}}}else{if let Some(ref tu)=telegram_user_opt{if let Some(cu)=user_service.get_user_by_telegram_id(tu.id).await?{if cu.state==UserState::Onboarding&&cu.name.is_none(){let nts=text.trim();if nts.is_empty()||nts.len()>50||nts.starts_with('/') {return Response::from_json!(&json!({"method":"sendMessage","chat_id":chat_id,"text":"Invalid name."}));}match user_service.update_user_state_and_name(cu.id.clone(),Some(nts.to_string()),UserState::Active).await {Ok(upd_u)=>{let mt=format!("Great, {}! Profile complete.\n\nMenu:\n/find_match\n/profile\n/help",escape_markdown_v2(upd_u.name.as_deref().unwrap_or_default()));Response::from_json!(&json!({"method":"sendMessage","chat_id":chat_id,"text":mt,"parse_mode":"MarkdownV2"}))}Err(_)=>Response::from_json!(&json!({"method":"sendMessage","chat_id":chat_id,"text":"Error saving name."}))}}else{Response::from_json!(&json!({"method":"sendMessage","chat_id":chat_id,"text":"Not sure what you mean."}))}}else{Response::from_json!(&json!({"method":"sendMessage","chat_id":chat_id,"text":"Please /start."}))}}else{Response::error("User info missing.",400)}}}

async fn handle_location_message( env: &Env, user_service: &UserService, _media_service: &MediaService, chat_id: i64, location: &TelegramLocation ) -> Result<Response> { if let Some(session)=get_profile_editing_session(env,chat_id).await?{let uid=session.user_id.clone();if matches!(session.step,CurrentEditingStep::AwaitingValue(EditingField::LocationText)){match user_service.update_user_location(&uid,None,Some(location.latitude),Some(location.longitude)).await{Ok(_)=>{clear_profile_editing_session(env,chat_id).await?;Response::from_json!(&json!({"method":"sendMessage","chat_id":chat_id,"text":format!("Location updated via pin \\(Lat: {:.3}, Lon: {:.3}\\)\\. /profile",location.latitude,location.longitude),"parse_mode":"MarkdownV2"}))}Err(e)=>{console_error!("Failed shared location update for {}: {}",uid,e);Response::from_json!(&json!({"method":"sendMessage","chat_id":chat_id,"text":"Error updating from pin\\. Try `cancel` or again\\."}))}}}else{Response::from_json!(&json!({"method":"sendMessage","chat_id":chat_id,"text":"Thanks for sharing\\! Not expecting location for profile edit now\\. Use `/profile edit` first\\." ,"parse_mode":"MarkdownV2"}))}}else{Response::from_json!(&json!({"method":"sendMessage","chat_id":chat_id,"text":"Thanks for sharing\\! To save to profile, use `/profile edit`\\.","parse_mode":"MarkdownV2"}))}}
async fn handle_media_message( env: &Env, user_service: &UserService, media_service: &MediaService, chat_id: i64, message: &TelegramMessage ) -> Result<Response> { let session_opt=get_profile_editing_session(env,chat_id).await?; if let Some(session)=session_opt{if session.step==CurrentEditingStep::AwaitingMediaFile{let uid=session.user_id.clone(); let u_check=user_service.get_user_by_id(&uid).await?.ok_or_else(||Error::RustError(format!("User {} not found",uid)))?; if u_check.media_keys.len()>=MAX_USER_MEDIA_ITEMS{clear_profile_editing_session(env,chat_id).await?;return Response::from_json!(&json!({"method":"sendMessage","chat_id":chat_id,"text":format!("Media limit ({}) reached\\.",MAX_USER_MEDIA_ITEMS),"parse_mode":"MarkdownV2"}));} let mut fid:Option<String>=None;let mut fname:Option<String>=None;let mut mime:Option<String>=None; if let Some(ref p)=message.photo{if let Some(lp)=p.iter().max_by_key(|ph|ph.width*ph.height){fid=Some(lp.file_id.clone());fname=Some(format!("{}.jpg",lp.file_unique_id));mime=Some("image/jpeg".to_string());}}else if let Some(ref v)=message.video{fid=Some(v.file_id.clone());fname=v.file_name.clone().or_else(||Some(format!("{}.mp4",v.file_unique_id)));mime=v.mime_type.clone();}else if let Some(ref d)=message.document{if let Some(m)=&d.mime_type{if m.starts_with("image/")||m.starts_with("video/"){fid=Some(d.file_id.clone());fname=d.file_name.clone();mime=d.mime_type.clone();}else{return Response::from_json!(&json!({"method":"sendMessage","chat_id":chat_id,"text":"Unsupported document type\\."}));}}else{return Response::from_json!(&json!({"method":"sendMessage","chat_id":chat_id,"text":"Could not determine file type\\."}));}} if let Some(file_id)=fid{let file_name_r2=fname.unwrap_or_else(||"uploaded_media".to_string());match download_telegram_file(env,&file_id).await{Ok(body)=>{match media_service.upload_media(&uid,file_name_r2,mime,body).await{Ok(r2k)=>{match user_service.add_media_key_to_user(&uid,r2k.clone()).await{Ok(_)=>{clear_profile_editing_session(env,chat_id).await?;Response::from_json!(&json!({"method":"sendMessage","chat_id":chat_id,"text":format!("Media added\\! Key: `{}`",escape_markdown_v2(&r2k)),"parse_mode":"MarkdownV2"}))}Err(e)=>{console_error!("Failed add media key {} to user {}: {}",r2k,uid,e);if let Err(del_e)=media_service.delete_media(&r2k).await{console_error!("CRITICAL: Orphaned R2 object {}: {}",r2k,del_e);}Response::from_json!(&json!({"method":"sendMessage","chat_id":chat_id,"text":"Error saving media to profile\\."}))}}}Err(e)=>{console_error!("R2 upload failed for {}: {}",uid,e);Response::from_json!(&json!({"method":"sendMessage","chat_id":chat_id,"text":"Error uploading media\\."}))}}}Err(e)=>{console_error!("Telegram download failed for {}: {}",uid,e);Response::from_json!(&json!({"method":"sendMessage","chat_id":chat_id,"text":"Error downloading media\\."}))}}}else{Response::from_json!(&json!({"method":"sendMessage","chat_id":chat_id,"text":"No supported media found\\."}))}}else{Response::from_json!(&json!({"method":"sendMessage","chat_id":chat_id,"text":"Not expecting media for profile edit now\\. Use `/profile add_media` first\\.","parse_mode":"MarkdownV2"}))}}else{Response::from_json!(&json!({"method":"sendMessage","chat_id":chat_id,"text":"To add media, use `/profile add_media` first\\.","parse_mode":"MarkdownV2"}))}}

async fn handle_profile_command( _user_service: &UserService, _rbac_service: &RBACService, _media_service: &MediaService, _env_config: &EnvironmentConfig, user: &DomainUser, chat_id: i64, _args: Vec<&str> ) -> Result<Response> { Response::from_json(&json!({ "method": "sendMessage", "chat_id": chat_id, "text": format_user_profile_view(user), "parse_mode": "MarkdownV2"})) }
async fn handle_find_match_command( _user_service: &UserService, _rbac_service: &RBACService, _media_service: &MediaService, _env_config: &EnvironmentConfig, user: &DomainUser, chat_id: i64, _args: Vec<&str> ) -> Result<Response> { Response::from_json(&json!({ "method": "sendMessage", "chat_id": chat_id, "text": "Looking for matches... (Placeholder - Feature coming soon!)" })) }
async fn handle_help_command( _user_service: &UserService, _rbac_service: &RBACService, _media_service: &MediaService, _env_config: &EnvironmentConfig, user: &DomainUser, chat_id: i64, _args: Vec<&str> ) -> Result<Response> { let user_name_escaped = escape_markdown_v2(user.name.as_deref().unwrap_or("there")); let mut help_text = format!("Hi {}!\n\nHere's how I can help:\n\n*/start* \\- Restart or main menu\\.\n*/profile* \\- View your profile\\.\n*/profile edit* \\- Start editing your profile\\.\n*/profile add_media* \\- Add a photo/video to your profile\\.\n*/profile delete_media* \\- Remove a photo/video from your profile\\.\n*/find_match* \\- Find a match\\.\n*/help* \\- This help message\\.\n\nMore features soon\\!", user_name_escaped); if user.roles.contains(&UserRole::Admin) { help_text.push_str("\n\n*Admin Commands:*\n/status \\- Check bot status\\."); } Response::from_json(&json!({ "method": "sendMessage", "chat_id": chat_id, "text": help_text, "parse_mode": "MarkdownV2" })) }
async fn handle_admin_status_command( _user_service: &UserService, _rbac_service: &RBACService, _media_service: &MediaService, _env_config: &EnvironmentConfig, user: &DomainUser, chat_id: i64, _args: Vec<&str> ) -> Result<Response> { Response::from_json(&json!({ "method": "sendMessage", "chat_id": chat_id, "text": "Bot status: Healthy\\! \\(Admin View\\)", "parse_mode": "MarkdownV2" })) }

async fn dispatch_command( env: &Env, user_service: &UserService, rbac_service: &RBACService, media_service: &MediaService, env_config: &EnvironmentConfig, telegram_user_opt: Option<TelegramUser>, chat_id: i64, text: &str ) -> Result<Response> {
    let mut parts = text.split_whitespace(); let command_str = parts.next().unwrap_or("").to_lowercase(); let args: Vec<&str> = parts.collect();
    let telegram_user = match telegram_user_opt { Some(tu) => tu, None => { return Response::from_json(&json!({"method": "sendMessage", "chat_id": chat_id, "text": "Cannot identify sender."})); } };
    let domain_user = match user_service.get_user_by_telegram_id(telegram_user.id).await? { Some(u) => u, None => { return Response::from_json(&json!({"method": "sendMessage", "chat_id": chat_id, "text": "Please use /start to begin."})); } };
    if !rbac_service.check_permission(&domain_user.roles, &command_str) { return Response::from_json(&json!({"method": "sendMessage", "chat_id": chat_id, "text": "You don't have permission for that."})); }
    match command_str.as_str() {
        "/profile" => {
            if args.first().map_or(false, |arg| arg.eq_ignore_ascii_case("edit")) { handle_profile_edit_initiate(env, &domain_user, chat_id).await }
            else if args.first().map_or(false, |arg| arg.eq_ignore_ascii_case("add_media")) { handle_profile_add_media_initiate(env, &domain_user, chat_id).await }
            else if args.first().map_or(false, |arg| arg.eq_ignore_ascii_case("delete_media")) { handle_profile_delete_media_initiate(env, user_service, &domain_user, chat_id).await }
            else if args.is_empty() { handle_profile_command(user_service, rbac_service, media_service, env_config, &domain_user, chat_id, args).await }
            else { Response::from_json(&json!({"method": "sendMessage", "chat_id": chat_id, "text": "Usage: `/profile`, `/profile edit`, `/profile add_media`, `/profile delete_media`\\." ,"parse_mode": "MarkdownV2"})) }
        }
        "/find_match" => handle_find_match_command(user_service, rbac_service, media_service, env_config, &domain_user, chat_id, args).await,
        "/help" => handle_help_command(user_service, rbac_service, media_service, env_config, &domain_user, chat_id, args).await,
        "/status" => { if domain_user.roles.contains(&UserRole::Admin) { handle_admin_status_command(user_service, rbac_service, media_service, env_config, &domain_user, chat_id, args).await } else { Response::from_json(&json!({"method": "sendMessage", "chat_id": chat_id, "text": "Admin only."})) } }
        _ => Response::from_json(&json!({"method": "sendMessage", "chat_id": chat_id, "text": format!("Unknown command: {}. Try /help.", command_str)}))
    }
}

async fn handle_start_command( user_service: &UserService, rbac_service: &RBACService, _media_service: &MediaService, env_config: &EnvironmentConfig, telegram_user_opt: Option<TelegramUser>, chat_id: i64 ) -> Result<Response> { /* ... */ let tu=match telegram_user_opt{Some(t)=>t,None=>{return Response::from_json!(&json!({"method":"sendMessage","chat_id":chat_id,"text":"Cannot identify you."}));}};match user_service.get_user_by_telegram_id(tu.id).await{Ok(Some(du))=>{if du.state==UserState::Blocked{return Response::from_json!(&json!({"method":"sendMessage","chat_id":chat_id,"text":"Blocked."}));}if !rbac_service.check_permission(&du.roles,"/start"){return Response::from_json!(&json!({"method":"sendMessage","chat_id":chat_id,"text":"Access denied."}));}if du.is_profile_complete(){let m=format!("Welcome back, {}!\n\nMenu:\n/find_match\n/profile\n/help",escape_markdown_v2(du.name.as_deref().unwrap_or("there")));return Response::from_json!(&json!({"method":"sendMessage","chat_id":chat_id,"text":m,"parse_mode":"MarkdownV2"}));}else{if du.name.is_none(){return Response::from_json!(&json!({"method":"sendMessage","chat_id":chat_id,"text":"Welcome! What's your name?"}));}else{match user_service.update_user_state_and_name(du.id.clone(),du.name.clone(),UserState::Active).await{Ok(u)=>{let mt=format!("Thanks, {}! Profile active.\n\nMenu:\n/find_match\n/profile\n/help",escape_markdown_v2(u.name.as_deref().unwrap_or_default()));Response::from_json!(&json!({"method":"sendMessage","chat_id":chat_id,"text":mt,"parse_mode":"MarkdownV2"}))}Err(_)=>Response::from_json!(&json!({"method":"sendMessage","chat_id":chat_id,"text":"Error activating."}))}}}}Ok(None)=>{match user_service.create_user_from_telegram_user(&tu).await{Ok(nu)=>{if !rbac_service.check_permission(&nu.roles,"/start"){return Response::from_json!(&json!({"method":"sendMessage","chat_id":chat_id,"text":"Permission error."}));}Response::from_json!(&json!({"method":"sendMessage","chat_id":chat_id,"text":"Welcome! What's your name?"}))}Err(_)=>Response::from_json!(&json!({"method":"sendMessage","chat_id":chat_id,"text":"Creation failed."}))}}Err(_)=>Response::from_json!(&json!({"method":"sendMessage","chat_id":chat_id,"text":"DB error."}))}}

#[event(fetch)]
pub async fn main(mut _req: Request, env: Env, _ctx: worker::Context) -> Result<Response> { /* ... */ utils::set_panic_hook(); let method=_req.method(); if method!=Method::Post{return Response::error("POST only",405);} let cfg_svc=ConfigService::new(); let env_cfg=match cfg_svc.get_environment_config(&env).await{Ok(c)=>c,Err(_)=>EnvironmentConfig::default()}; let upd:TelegramUpdate=match _req.json().await{Ok(u)=>u,Err(e)=>{return Response::error(format!("Bad req: {}",e),400);}}; let mut final_res:Result<Response>=Response::empty()?.with_status(200); let mut uid_interaction:Option<String>=None; if let Some(msg)=upd.message{let cid=msg.chat.id; let tu_opt=msg.from.clone(); let usr_svc=match UserService::new(&env){Ok(s)=>s,Err(_)=>{return Response::from_json!(&json!({"method":"sendMessage","chat_id":cid,"text":"Internal error."}));}}; let rbac_svc=RBACService::new(); let media_svc=match MediaService::new(&env){Ok(s)=>s,Err(_)=>{return Response::from_json!(&json!({"method":"sendMessage","chat_id":cid,"text":"Media service error."}));}}; if let Some(ref tu)=tu_opt{if let Ok(Some(u))=usr_svc.get_user_by_telegram_id(tu.id).await{uid_interaction=Some(u.id.clone());}} if msg.photo.is_some()||msg.video.is_some()||msg.document.is_some(){final_res=handle_media_message(&env,&usr_svc,&media_svc,cid,&msg).await;}else if let Some(ref loc)=msg.location{final_res=handle_location_message(&env,&usr_svc,&media_svc,cid,loc).await;}else if let Some(txt)=msg.text{let tt=txt.trim(); if tt.starts_with("/start"){final_res=handle_start_command(&usr_svc,&rbac_svc,&media_svc,&env_cfg,tu_opt.clone(),cid).await;}else if tt.starts_with("/"){final_res=dispatch_command(&env,&usr_svc,&rbac_svc,&media_svc,&env_cfg,tu_opt.clone(),cid,&tt).await;}else{final_res=handle_text_message(&env,&usr_svc,&media_svc,&env_cfg,tu_opt.clone(),cid,&tt).await;}}else{final_res=Ok(Response::from_json!(&json!({"method":"sendMessage","chat_id":cid,"text":"Text, location, photo, video, or doc only."}))?);} if uid_interaction.is_none(){if let Some(ref tu)=tu_opt{if let Ok(Some(u))=usr_svc.get_user_by_telegram_id(tu.id).await{uid_interaction=Some(u.id.clone());}}} if let Some(uid)=uid_interaction{if let Err(e)=usr_svc.record_user_interaction(&uid).await{console_error!("[Main] Failed record interaction {}: {}",uid,e);}}}else{console_log!("[Main] No message in update.");} final_res }

// --- Tests for lib.rs ---
#[cfg(test)]
mod lib_tests {
    use super::*;
    use crate::user_service::{User as DomainUser, UserState, default_user_roles, default_media_keys};
    use crate::rbac_service::Role as UserTestRole;
    use chrono::{TimeZone, Utc};
    use serde_json; // For deserialization tests

    fn create_domain_user_for_lib_test( name: Option<String>, age: Option<u8>, gender: Option<String>, bio: Option<String>, location_text: Option<String>, latitude: Option<f64>, longitude: Option<f64>, media_keys: Vec<String>, state: UserState, roles: Vec<UserTestRole>, created_at_str: &str, last_interaction_at_str: &str ) -> DomainUser { DomainUser { id: "domain_user_test_id".to_string(), telegram_id: 123456, telegram_username: Some("libtester".to_string()), name, age, gender, bio, location_text, latitude, longitude, media_keys, created_at: Utc.datetime_from_str(created_at_str, "%Y-%m-%dT%H:%M:%SZ").unwrap(), updated_at: Utc.datetime_from_str(last_interaction_at_str, "%Y-%m-%dT%H:%M:%SZ").unwrap(), last_interaction_at: Utc.datetime_from_str(last_interaction_at_str, "%Y-%m-%dT%H:%M:%SZ").unwrap(), state, roles, } }

    #[test]
    fn test_escape_markdown_v2_common_chars() { /* ... */ }
    #[test]
    fn test_format_user_profile_view_all_fields_with_markdown_chars() { /* ... */ }
    #[test]
    fn test_format_user_profile_view_some_fields_none() { /* ... */ }
    #[test]
    fn test_format_user_profile_location_variants_formatting() { /* ... */ }
    #[test]
    fn test_format_user_profile_empty_bio_and_name() { /* ... */ }

    #[cfg(test)]
    mod validation_tests { /* ... existing validation tests ... */ use super::*; #[test]fn test_validate_name_valid(){assert!(validate_name("John Doe").is_ok());assert!(validate_name("J").is_ok());assert!(validate_name(&"a".repeat(MAX_NAME_LEN)).is_ok());}#[test]fn test_validate_name_invalid(){assert_eq!(validate_name("").unwrap_err(),ValidationError::TooShort(MIN_NAME_LEN));assert_eq!(validate_name("   ").unwrap_err(),ValidationError::TooShort(MIN_NAME_LEN));assert_eq!(validate_name(&"a".repeat(MAX_NAME_LEN+1)).unwrap_err(),ValidationError::TooLong(MAX_NAME_LEN));}#[test]fn test_validate_age_valid(){assert_eq!(validate_age("25").unwrap(),25);assert_eq!(validate_age(&MIN_AGE.to_string()).unwrap(),MIN_AGE);assert_eq!(validate_age(&MAX_AGE.to_string()).unwrap(),MAX_AGE);}#[test]fn test_validate_age_invalid(){assert_eq!(validate_age("abc").unwrap_err().to_string(),ValidationError::InvalidFormat("Age must be a number.".to_string()).to_string());assert_eq!(validate_age(&(MIN_AGE-1).to_string()).unwrap_err(),ValidationError::OutOfRange{min:MIN_AGE.to_string(),max:MAX_AGE.to_string()});assert_eq!(validate_age(&(MAX_AGE+1).to_string()).unwrap_err(),ValidationError::OutOfRange{min:MIN_AGE.to_string(),max:MAX_AGE.to_string()});assert_eq!(validate_age(" 12 ").unwrap_err(),ValidationError::OutOfRange{min:MIN_AGE.to_string(),max:MAX_AGE.to_string()});}#[test]fn test_validate_gender(){assert!(validate_gender("Male").is_ok());assert!(validate_gender("").is_ok());assert!(validate_gender(&"a".repeat(MAX_GENDER_LEN)).is_ok());assert_eq!(validate_gender(&"a".repeat(MAX_GENDER_LEN+1)).unwrap_err(),ValidationError::TooLong(MAX_GENDER_LEN));}#[test]fn test_validate_bio(){assert!(validate_bio("This is a bio.").is_ok());assert!(validate_bio("").is_ok());assert!(validate_bio(&"b".repeat(MAX_BIO_LEN)).is_ok());assert_eq!(validate_bio(&"b".repeat(MAX_BIO_LEN+1)).unwrap_err(),ValidationError::TooLong(MAX_BIO_LEN));}#[test]fn test_validate_location_text(){assert!(validate_location_text("City, Country").is_ok());assert!(validate_location_text("").is_ok());assert!(validate_location_text("  ").is_ok());assert!(validate_location_text(&"l".repeat(MAX_LOCATION_TEXT_LEN)).is_ok());assert_eq!(validate_location_text(&"l".repeat(MAX_LOCATION_TEXT_LEN+1)).unwrap_err(),ValidationError::TooLong(MAX_LOCATION_TEXT_LEN));}}

    #[test]
    fn test_deserialize_telegram_message_with_photo() {
        let json_str = r#"{ "message_id": 123, "date": 1678886400, "chat": {"id": 100, "type": "private"}, "from": {"id": 200, "is_bot": false, "first_name": "Test", "username": "tester"}, "photo": [ {"file_id": "small_photo_id", "file_unique_id": "small_unique", "width": 100, "height": 100}, {"file_id": "large_photo_id", "file_unique_id": "large_unique", "width": 500, "height": 500, "file_size": 12345} ] }"#;
        let result: Result<TelegramMessage, _> = serde_json::from_str(json_str);
        assert!(result.is_ok(), "Failed to deserialize photo message: {:?}", result.err());
        let message = result.unwrap();
        assert!(message.photo.is_some());
        assert_eq!(message.photo.as_ref().unwrap().len(), 2);
        assert_eq!(message.photo.as_ref().unwrap()[1].file_id, "large_photo_id");
    }

    #[test]
    fn test_deserialize_telegram_message_with_video() {
        let json_str = r#"{ "message_id": 124, "date": 1678886401, "chat": {"id": 101, "type": "private"}, "from": {"id": 201, "is_bot": false, "first_name": "VideoUser"}, "video": { "file_id": "video_id", "file_unique_id": "video_unique", "width": 640, "height": 480, "duration": 30, "mime_type": "video/mp4", "file_name": "cool_video.mp4", "file_size": 50000 } }"#;
        let result: Result<TelegramMessage, _> = serde_json::from_str(json_str);
        assert!(result.is_ok(), "Failed to deserialize video message: {:?}", result.err());
        let message = result.unwrap();
        assert!(message.video.is_some());
        assert_eq!(message.video.as_ref().unwrap().file_id, "video_id");
        assert_eq!(message.video.as_ref().unwrap().file_name, Some("cool_video.mp4".to_string()));
    }

    #[test]
    fn test_deserialize_telegram_message_with_document() {
        let json_str = r#"{ "message_id": 125, "date": 1678886402, "chat": {"id": 102, "type": "private"}, "from": {"id": 202, "is_bot": false, "first_name": "DocUser"}, "document": { "file_id": "doc_id", "file_unique_id": "doc_unique", "file_name": "report.pdf", "mime_type": "application/pdf", "file_size": 100000 } }"#;
        let result: Result<TelegramMessage, _> = serde_json::from_str(json_str);
        assert!(result.is_ok(), "Failed to deserialize document message: {:?}", result.err());
        let message = result.unwrap();
        assert!(message.document.is_some());
        assert_eq!(message.document.as_ref().unwrap().file_name, Some("report.pdf".to_string()));
    }

    #[test]
    fn test_deserialize_telegram_message_with_location() {
        let json_str = r#"{ "message_id": 126, "date": 1678886403, "chat": {"id": 103, "type": "private"}, "from": {"id": 203, "is_bot": false, "first_name": "LocationUser"}, "location": { "latitude": 34.0522, "longitude": -118.2437 } }"#;
        let result: Result<TelegramMessage, _> = serde_json::from_str(json_str);
        assert!(result.is_ok(), "Failed to deserialize location message: {:?}", result.err());
        let message = result.unwrap();
        assert!(message.location.is_some());
        assert_eq!(message.location.as_ref().unwrap().latitude, 34.0522);
    }

    #[test]
    fn test_deserialize_telegram_getfile_response() {
        let json_ok_str = r#"{ "ok": true, "result": { "file_id": "file_abc", "file_unique_id": "unique_abc", "file_size": 12345, "file_path": "photos/some_photo.jpg" } }"#;
        let result_ok: Result<TelegramApiResponse<TelegramFile>, _> = serde_json::from_str(json_ok_str);
        assert!(result_ok.is_ok(), "Failed to deserialize OK getFile response: {:?}", result_ok.err());
        let response_ok = result_ok.unwrap();
        assert!(response_ok.ok);
        assert!(response_ok.result.is_some());
        assert_eq!(response_ok.result.as_ref().unwrap().file_path, Some("photos/some_photo.jpg".to_string()));

        let json_err_str = r#"{ "ok": false, "error_code": 400, "description": "File not found" }"#;
        let result_err: Result<TelegramApiResponse<TelegramFile>, _> = serde_json::from_str(json_err_str);
        assert!(result_err.is_ok(), "Failed to deserialize Error getFile response: {:?}", result_err.err());
        let response_err = result_err.unwrap();
        assert!(!response_err.ok);
        assert!(response_err.result.is_none());
        assert_eq!(response_err.description, Some("File not found".to_string()));
    }
}
